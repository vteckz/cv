<!--
  Linton Evans - 3D Interactive CV Portfolio
  Copyright (c) 2025 Linton Evans. All rights reserved.

  This source code is proprietary and confidential.
  Unauthorized copying, modification, distribution, or use of this code,
  via any medium, is strictly prohibited without express written permission.

  Contact: linton.evans@outlook.com
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Linton Evans | Technical Specialist - 3D Portfolio</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Inter', sans-serif; background: var(--bg-color, #000); color: var(--text-color, #fff); transition: background 0.5s ease, color 0.5s ease; }

    /* Theme Variables */
    :root {
      --bg-color: #000;
      --bg-secondary: #0a0a15;
      --text-color: #fff;
      --text-muted: rgba(255,255,255,0.7);
      --accent-color: #a3e635;
      --accent-dark: #65a30d;
      --panel-bg: rgba(10, 10, 15, 0.95);
      --panel-border: rgba(163, 230, 53, 0.3);
    }

    /* Firefox-specific rendering optimizations */
    @supports (-moz-appearance: none) {
      /* Disable hardware acceleration for clearer text in Firefox */
      .pdf-page canvas, .curl-page canvas {
        image-rendering: auto;
        -moz-osx-font-smoothing: grayscale;
      }
      /* Reduce animation complexity for Firefox */
      .booklet-container {
        transition: width 0.3s ease, height 0.3s ease;
      }
    }

    /* Neural Network Background - ALWAYS visible */
    #neural-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 0;
      background: #0a0a15;
    }

    #canvas-container {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 1;
    }

    #loading-screen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: transparent;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 1000; transition: opacity 0.8s ease;
    }
    #loading-screen.hidden { opacity: 0; pointer-events: none; }

    .loading-box {
      width: 80px; height: 80px; position: relative;
      transform-style: preserve-3d; animation: rotateBox 2s ease-in-out infinite;
    }
    .loading-box::before {
      content: ''; position: absolute; width: 100%; height: 100%;
      background: linear-gradient(135deg, #a3e635, #65a30d);
      border-radius: 8px; animation: pulse 1s ease-in-out infinite alternate;
    }
    @keyframes rotateBox { 0%,100%{transform:rotateY(0deg)} 50%{transform:rotateY(180deg)} }
    @keyframes pulse { from{box-shadow:0 0 20px rgba(163,230,53,0.4)} to{box-shadow:0 0 40px rgba(163,230,53,0.8)} }
    .loading-text { margin-top: 30px; font-family: 'Space Grotesk', sans-serif; font-size: 1.2rem; color: #a3e635; letter-spacing: 2px; }
    .loading-progress { margin-top: 20px; width: 200px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
    .loading-progress-bar { height: 100%; background: linear-gradient(90deg, #a3e635, #65a30d); width: 0%; transition: width 0.3s; }

    #ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 200; }
    #ui-overlay > * { pointer-events: auto; }

    #start-btn {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      padding: 18px 50px; font-family: 'Space Grotesk', sans-serif;
      font-size: 1.1rem; font-weight: 600; letter-spacing: 2px; text-transform: uppercase;
      background: linear-gradient(135deg, #a3e635, #65a30d);
      color: #0a0a0f; border: none; border-radius: 50px; cursor: pointer;
      box-shadow: 0 0 30px rgba(163, 230, 53, 0.4); display: none; z-index: 200;
    }
    #start-btn:hover { transform: translate(-50%, -50%) scale(1.05); box-shadow: 0 0 50px rgba(163, 230, 53, 0.6); }
    #start-btn.visible { display: block; animation: fadeIn 0.5s ease; }
    @keyframes fadeIn { from{opacity:0;transform:translate(-50%,-40%)} to{opacity:1;transform:translate(-50%,-50%)} }

    .nav-container {
      position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
      display: none; gap: 12px; background: rgba(10, 10, 15, 0.8);
      backdrop-filter: blur(20px); padding: 12px 20px; border-radius: 50px;
      border: 1px solid rgba(163, 230, 53, 0.2);
      z-index: 50;
    }
    /* Hide section nav when booklet is visible */
    #pdf-booklet.visible ~ #ui-overlay .nav-container { display: none !important; }
    .nav-btn { width: 12px; height: 12px; border-radius: 50%; background: rgba(255,255,255,0.3); border: none; cursor: pointer; }
    .nav-btn:hover { background: rgba(163, 230, 53, 0.6); transform: scale(1.2); }
    .nav-btn.active { background: #a3e635; box-shadow: 0 0 15px rgba(163, 230, 53, 0.6); }

    .audio-controls { position: absolute; top: 30px; right: 30px; display: flex; gap: 10px; }
    .audio-btn {
      width: 44px; height: 44px; border-radius: 50%;
      background: rgba(10, 10, 15, 0.8); backdrop-filter: blur(20px);
      border: 1px solid rgba(163, 230, 53, 0.3); color: #fff;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
    }
    .audio-btn:hover { border-color: #a3e635; background: rgba(163, 230, 53, 0.1); }
    .audio-btn svg { width: 20px; height: 20px; }

    .info-panel {
      position: absolute; max-width: 320px; z-index: 500;
      background: rgba(10, 10, 15, 0.95); backdrop-filter: blur(20px);
      padding: 25px; border-radius: 16px; border: 1px solid rgba(163, 230, 53, 0.2);
      opacity: 0; transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .info-panel.visible { opacity: 1; }
    /* Position variants for info panel */
    .info-panel.pos-top-left { top: 30px; left: 30px; transform: translate(-20px, 0); }
    .info-panel.pos-top-left.visible { transform: translate(0, 0); }
    .info-panel.pos-top-right { top: 30px; right: 30px; left: auto; transform: translate(20px, 0); }
    .info-panel.pos-top-right.visible { transform: translate(0, 0); }
    .info-panel.pos-bottom-left { bottom: 140px; top: auto; left: 30px; transform: translate(-20px, 0); }
    .info-panel.pos-bottom-left.visible { transform: translate(0, 0); }
    .info-panel.pos-bottom-right { bottom: 140px; top: auto; right: 30px; left: auto; transform: translate(20px, 0); }
    .info-panel.pos-bottom-right.visible { transform: translate(0, 0); }
    .info-panel h2 { font-family: 'Space Grotesk', sans-serif; font-size: 1.5rem; margin-bottom: 8px; color: #a3e635; }
    .info-panel h3 { font-size: 0.9rem; color: rgba(255,255,255,0.7); margin-bottom: 15px; }
    .info-panel p { font-size: 0.85rem; line-height: 1.5; color: rgba(255,255,255,0.85); white-space: pre-line; }

    .speech-bubble {
      position: absolute; max-width: 340px; z-index: 500;
      background: rgba(10, 10, 15, 0.95); backdrop-filter: blur(20px);
      padding: 16px 22px; border-radius: 18px; border: 1px solid rgba(163, 230, 53, 0.3);
      opacity: 0;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(163, 230, 53, 0.1);
    }
    .speech-bubble::before {
      content: ''; position: absolute; width: 0; height: 0;
      border: 10px solid transparent;
    }

    /* Different entrance animations */
    @keyframes bubbleFadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
    @keyframes bubbleSlideLeft { from { opacity: 0; transform: translateX(-50px); } to { opacity: 1; transform: translateX(0); } }
    @keyframes bubbleSlideRight { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }
    @keyframes bubbleSlideUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes bubbleSlideDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes bubblePop { from { opacity: 0; transform: scale(0.3); } 50% { transform: scale(1.1); } to { opacity: 1; transform: scale(1); } }
    @keyframes bubbleSwing { from { opacity: 0; transform: rotate(-10deg) scale(0.8); } to { opacity: 1; transform: rotate(0deg) scale(1); } }

    .speech-bubble.visible { opacity: 1; }
    .speech-bubble.anim-fade.visible { animation: bubbleFadeIn 0.5s ease-out forwards; }
    .speech-bubble.anim-slide-left.visible { animation: bubbleSlideLeft 0.5s ease-out forwards; }
    .speech-bubble.anim-slide-right.visible { animation: bubbleSlideRight 0.5s ease-out forwards; }
    .speech-bubble.anim-slide-up.visible { animation: bubbleSlideUp 0.5s ease-out forwards; }
    .speech-bubble.anim-slide-down.visible { animation: bubbleSlideDown 0.5s ease-out forwards; }
    .speech-bubble.anim-pop.visible { animation: bubblePop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    .speech-bubble.anim-swing.visible { animation: bubbleSwing 0.5s ease-out forwards; }

    /* Position variants for speech bubble */
    /* TOP LEFT - upper left corner */
    .speech-bubble.pos-top-left { top: 20px; left: 20px; max-width: 280px; transform: translate(-20px, -20px) scale(0.9); }
    .speech-bubble.pos-top-left.visible { transform: translate(0, 0) scale(1); }
    .speech-bubble.pos-top-left::before { bottom: -20px; left: 30px; border-top-color: rgba(163, 230, 53, 0.3); }

    /* BOTTOM LEFT - lower left corner */
    .speech-bubble.pos-bottom-left { bottom: 120px; top: auto; left: 20px; max-width: 280px; transform: translate(-20px, 20px) scale(0.9); }
    .speech-bubble.pos-bottom-left.visible { transform: translate(0, 0) scale(1); }
    .speech-bubble.pos-bottom-left::before { top: -20px; left: 30px; border-bottom-color: rgba(163, 230, 53, 0.3); }

    /* MID LEFT - vertically centered on left, pointer points right */
    .speech-bubble.pos-mid-left { top: 50%; left: 20px; max-width: 280px; transform: translate(-20px, -50%) scale(0.9); }
    .speech-bubble.pos-mid-left.visible { transform: translate(0, -50%) scale(1); }
    .speech-bubble.pos-mid-left::before { right: -20px; top: 50%; margin-top: -10px; border-left-color: rgba(163, 230, 53, 0.3); }

    /* TOP RIGHT - upper right corner */
    .speech-bubble.pos-top-right { top: 20px; right: 20px; left: auto; max-width: 280px; transform: translate(20px, -20px) scale(0.9); }
    .speech-bubble.pos-top-right.visible { transform: translate(0, 0) scale(1); }
    .speech-bubble.pos-top-right::before { bottom: -20px; right: 30px; border-top-color: rgba(163, 230, 53, 0.3); }

    /* BOTTOM RIGHT - lower right corner */
    .speech-bubble.pos-bottom-right { bottom: 120px; top: auto; right: 20px; left: auto; max-width: 280px; transform: translate(20px, 20px) scale(0.9); }
    .speech-bubble.pos-bottom-right.visible { transform: translate(0, 0) scale(1); }
    .speech-bubble.pos-bottom-right::before { top: -20px; right: 30px; border-bottom-color: rgba(163, 230, 53, 0.3); }

    /* CENTER - below content */
    .speech-bubble.pos-center { bottom: 90px; left: 50%; max-width: 500px; transform: translateX(-50%) translateY(20px) scale(0.9); }
    .speech-bubble.pos-center.visible { transform: translateX(-50%) translateY(0) scale(1); }
    .speech-bubble.pos-center::before { display: none; }
    .speech-bubble.pos-center p { text-align: center; }

    /* Dynamic positioned bubbles */
    .speech-bubble.pos-dynamic { max-width: 300px; transform: scale(0.9); }
    .speech-bubble.pos-dynamic.visible { transform: scale(1); }
    .speech-bubble.pos-dynamic::before { display: none; }

    .speech-bubble p { font-size: 0.9rem; line-height: 1.5; text-align: left; }

    /* Bubble adjusts when page is zoomed */
    .booklet-container.zoomed ~ #ui-overlay .speech-bubble:not(.pos-center),
    .booklet-container.zoomed-max ~ #ui-overlay .speech-bubble:not(.pos-center) {
      max-width: 240px;
      font-size: 0.85rem;
    }
    .speech-bubble .section-icon { display: inline-block; margin-right: 8px; color: #a3e635; }

    #pdf-booklet {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      display: none; z-index: 150;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      opacity: 0;
      transition: opacity 0.6s ease;
      /* Disable ALL browser touch handling - we manage it in JS */
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #pdf-booklet.visible {
      display: flex;
      opacity: 1;
    }
    #pdf-booklet.entering .booklet-container {
      animation: bookletEnter 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    @keyframes bookletEnter {
      from { transform: scale(0.3) rotateY(90deg); opacity: 0; }
      to { transform: scale(1) rotateY(0deg); opacity: 1; }
    }
    .booklet-container {
      position: relative;
      /* Dynamic sizing based on viewport - will be set by JS */
      width: var(--booklet-width, 450px);
      height: var(--booklet-height, 620px);
      transform-style: preserve-3d;
      transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.15s ease-out;
      transform: translateY(var(--scroll-offset, 0px));
      /* Disable ALL browser touch gestures - we handle them ourselves */
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .booklet-container.zoomed {
      transform: scale(var(--zoom-scale-1, 1.4)) translateY(var(--scroll-offset, 0px));
    }
    .booklet-container.zoomed-max {
      transform: scale(var(--zoom-scale-2, 1.8)) translateY(var(--scroll-offset, 0px));
    }
    .booklet-container.zoomed-ultra {
      transform: scale(var(--zoom-scale-3, 2.2)) translateY(var(--scroll-offset, 0px));
    }
    /* Temporary pinch-hold zoom beyond level 3 */
    .booklet-container.temp-zoom {
      transition: transform 0.1s ease-out !important;
    }
    .booklet-container.temp-zoom-release {
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) !important;
    }

    /* Let's Go popup */
    #lets-go-popup {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0);
      font-family: 'Space Grotesk', sans-serif;
      font-size: 3rem;
      font-weight: 700;
      color: #a3e635;
      text-shadow: 0 0 30px rgba(163, 230, 53, 0.8), 0 0 60px rgba(163, 230, 53, 0.4);
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      white-space: nowrap;
    }
    #lets-go-popup.visible {
      animation: letsGoAnim 2s ease-out forwards;
    }
    @keyframes letsGoAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.3) rotate(5deg); }
      40% { transform: translate(-50%, -50%) scale(1) rotate(-3deg); }
      60% { transform: translate(-50%, -50%) scale(1.1) rotate(2deg); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(0deg); }
      100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8) rotate(0deg); }
    }

    /* Connect Now button */
    #connect-now-btn {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0);
      padding: 18px 45px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.2rem;
      font-weight: 600;
      letter-spacing: 1px;
      background: linear-gradient(135deg, #a3e635, #65a30d);
      color: #0a0a0f;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 0 30px rgba(163, 230, 53, 0.4), 0 10px 40px rgba(0,0,0,0.3);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #connect-now-btn:hover {
      box-shadow: 0 0 50px rgba(163, 230, 53, 0.6), 0 15px 50px rgba(0,0,0,0.4);
      transform: translate(-50%, -50%) scale(1.05);
    }
    #connect-now-btn.visible {
      opacity: 1;
      pointer-events: auto;
      animation: connectBtnAnim 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    #connect-now-btn.stacked {
      position: fixed;
      top: auto;
      left: auto;
      bottom: 30px;
      right: 30px;
      transform: none;
      animation: connectBtnStack 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      padding: 12px 20px;
      font-size: 0.9rem;
      z-index: 301;
    }
    #connect-now-btn.stacked:hover {
      transform: translateY(-3px);
    }
    @keyframes connectBtnStack {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 1; transform: none; }
    }
    #connect-now-btn svg {
      width: 22px;
      height: 22px;
    }
    @keyframes connectBtnAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    /* Persistent contact bubble */
    #contact-persistent {
      position: fixed;
      top: 100px;
      right: 30px;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(20px);
      padding: 20px 25px;
      border-radius: 16px;
      border: 1px solid rgba(163, 230, 53, 0.3);
      z-index: 900;
      opacity: 0;
      pointer-events: none;
      transform: translateX(30px);
      transition: opacity 0.5s ease, transform 0.5s ease;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(163, 230, 53, 0.1);
    }
    #contact-persistent.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(0);
    }
    #contact-persistent h4 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1rem;
      color: #a3e635;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #contact-persistent h4 svg {
      width: 18px;
      height: 18px;
    }
    #contact-persistent .contact-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: rgba(255,255,255,0.9);
    }
    #contact-persistent .contact-item:last-child {
      margin-bottom: 0;
    }
    #contact-persistent .contact-item svg {
      width: 16px;
      height: 16px;
      color: #a3e635;
      flex-shrink: 0;
    }
    #contact-persistent a {
      color: rgba(255,255,255,0.9);
      text-decoration: none;
      transition: color 0.2s ease;
    }
    #contact-persistent a:hover {
      color: #a3e635;
    }

    /* Single page view - main page container */
    .page-stack {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
    }

    /* Individual page styling */
    .pdf-page {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0; top: 0;
      background: #fff; border-radius: 8px;
      box-shadow: 0 15px 50px rgba(0,0,0,0.6), 0 5px 15px rgba(0,0,0,0.3);
      overflow: hidden; cursor: zoom-in;
      /* Disable browser touch gestures - parent handles everything */
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .pdf-page:hover { box-shadow: 0 20px 60px rgba(0,0,0,0.7), 0 8px 20px rgba(0,0,0,0.4); }
    .booklet-container.zoomed .pdf-page, .booklet-container.zoomed-max .pdf-page, .booklet-container.zoomed-ultra .pdf-page { cursor: zoom-out; }
    .pdf-page canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* Use high quality rendering */
      image-rendering: auto;
      image-rendering: high-quality;
    }

    /* Current page - visible */
    .pdf-page.current {
      z-index: 10;
      opacity: 1;
    }

    /* Next page - hidden underneath */
    .pdf-page.next {
      z-index: 5;
      opacity: 0;
    }

    /* ============================================
       PAPER CURL PAGE TURN SYSTEM
       Corner peel effect - curls from top-right
       ============================================ */

    /* Curl container that holds the curling page */
    .page-curl-container {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0; top: 0;
      transform-style: preserve-3d;
      perspective: 1200px;
      z-index: 20;
      pointer-events: none;
      opacity: 0;
      overflow: visible;
    }

    .page-curl-container.active {
      opacity: 1;
    }

    /* The curling page element */
    .curl-page {
      position: absolute;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      transform-origin: bottom left;
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
      box-shadow: 0 15px 50px rgba(0,0,0,0.5);
    }

    .curl-page canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: auto;
      image-rendering: high-quality;
    }

    /* Shadow that appears under the curling page */
    .curl-shadow {
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at top right,
        rgba(0,0,0,0.4) 0%,
        rgba(0,0,0,0.2) 30%,
        rgba(0,0,0,0) 70%
      );
      opacity: 0;
      pointer-events: none;
      border-radius: 8px;
    }

    /* Gradient overlay on curling page for depth */
    .curl-gradient {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(
        -45deg,
        rgba(0,0,0,0.15) 0%,
        rgba(0,0,0,0.05) 30%,
        rgba(255,255,255,0.05) 50%,
        rgba(0,0,0,0) 100%
      );
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      border-radius: 8px;
    }

    /* Page turn animations for underlying page */
    .pdf-page.turning-out {
      opacity: 0;
      z-index: 5;
    }
    .pdf-page.turning-in {
      animation: pageRevealSmooth 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      z-index: 10;
    }

    /* Backward page turn */
    .pdf-page.turning-back-out {
      opacity: 0;
      z-index: 5;
    }
    .pdf-page.turning-back-in {
      animation: pageRevealSmooth 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      z-index: 10;
    }

    /* New page smoothly revealed underneath */
    @keyframes pageRevealSmooth {
      0% {
        transform: scale(0.97);
        opacity: 0.3;
        box-shadow: 0 5px 15px rgba(0,0,0,0.15);
      }
      40% {
        transform: scale(0.99);
        opacity: 0.7;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      }
      100% {
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 15px 50px rgba(0,0,0,0.5);
      }
    }

    /* Page shadow/depth stack effect */
    .page-stack::before {
      content: '';
      position: absolute;
      width: calc(100% - 4px);
      height: calc(100% - 4px);
      left: 2px; top: 4px;
      background: #f5f5f5;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 1;
    }
    .page-stack::after {
      content: '';
      position: absolute;
      width: calc(100% - 8px);
      height: calc(100% - 8px);
      left: 4px; top: 6px;
      background: #eee;
      border-radius: 8px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      z-index: 0;
    }

    /* Hide spine in single page mode */
    .booklet-spine { display: none; }

    .booklet-nav { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 15px; background: rgba(10,10,15,0.9); padding: 14px 28px; border-radius: 35px; border: 1px solid rgba(163,230,53,0.3); z-index: 160; }
    .booklet-nav button { width: 40px; height: 40px; border-radius: 50%; background: rgba(163,230,53,0.2); border: 1px solid rgba(163,230,53,0.4); color: #a3e635; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
    .booklet-nav button:hover:not(:disabled) { background: rgba(163,230,53,0.4); transform: scale(1.1); }
    .booklet-nav button:disabled { opacity: 0.3; cursor: not-allowed; }
    .booklet-nav button svg { width: 20px; height: 20px; }
    .page-indicator { font-family: 'Space Grotesk', sans-serif; font-size: 0.9rem; color: #fff; min-width: 80px; text-align: center; }
    .booklet-close { position: fixed; top: 30px; right: 30px; width: 40px; height: 40px; border-radius: 50%; background: rgba(10,10,15,0.9); border: 1px solid rgba(255,255,255,0.2); color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; z-index: 160; }
    .booklet-close:hover { background: rgba(255,100,100,0.3); transform: scale(1.1); }
    #zoom-btn { background: rgba(74,144,217,0.2); border-color: rgba(74,144,217,0.4); color: #4a90d9; }
    #zoom-btn.active { background: rgba(74,144,217,0.5); }

    #view-cv-btn { position: fixed; top: 30px; left: 30px; padding: 10px 24px; font-family: 'Space Grotesk', sans-serif; font-size: 0.9rem; background: rgba(10,10,15,0.8); backdrop-filter: blur(20px); border: 1px solid rgba(163,230,53,0.4); color: #a3e635; border-radius: 25px; cursor: pointer; display: none; z-index: 160; }
    #view-cv-btn.visible { display: block; }
    #view-cv-btn:hover { background: rgba(163,230,53,0.2); }

    /* Page overview grid */
    #page-overview {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(10px);
      z-index: 300;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 40px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    #page-overview.visible {
      opacity: 1;
      visibility: visible;
    }
    .overview-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      max-width: 900px;
      width: 100%;
    }
    .overview-page {
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      position: relative;
      opacity: 0;
      transform: scale(0.9);
    }
    #page-overview.visible .overview-page {
      opacity: 1;
      transform: scale(1);
    }
    #page-overview.visible .overview-page:nth-child(1) { transition-delay: 0.05s; }
    #page-overview.visible .overview-page:nth-child(2) { transition-delay: 0.1s; }
    #page-overview.visible .overview-page:nth-child(3) { transition-delay: 0.15s; }
    #page-overview.visible .overview-page:nth-child(4) { transition-delay: 0.2s; }
    .overview-page:hover {
      transform: scale(1.03);
      box-shadow: 0 8px 40px rgba(163, 230, 53, 0.3);
    }
    .overview-page canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .overview-page-label {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10, 10, 15, 0.9);
      color: #a3e635;
      padding: 5px 15px;
      border-radius: 15px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.8rem;
    }
    .overview-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(10,10,15,0.9);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.3s ease;
      z-index: 310;
    }
    .overview-close:hover {
      background: rgba(255,100,100,0.3);
      transform: scale(1.1);
    }
    .overview-title {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #a3e635;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.2rem;
      font-weight: 600;
    }

    /* Zoom hint tooltip */
    .zoom-hint {
      position: fixed;
      top: 50%;
      right: 30px;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(20px);
      padding: 12px 18px;
      border-radius: 30px;
      border: 1px solid rgba(163, 230, 53, 0.4);
      color: #fff;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.85rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      z-index: 160;
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    }
    .zoom-hint.visible {
      opacity: 1;
      animation: hintPulse 2s ease-in-out infinite, hintFadeIn 0.5s ease-out;
    }
    .zoom-hint .arrow {
      width: 24px;
      height: 24px;
      color: #a3e635;
      animation: arrowBounce 1s ease-in-out infinite;
    }
    .zoom-hint .hint-text {
      color: rgba(255,255,255,0.9);
    }
    .zoom-hint .hint-text strong {
      color: #a3e635;
    }
    @keyframes hintPulse {
      0%, 100% { box-shadow: 0 5px 20px rgba(0,0,0,0.4), 0 0 0 0 rgba(163, 230, 53, 0.4); }
      50% { box-shadow: 0 5px 20px rgba(0,0,0,0.4), 0 0 0 8px rgba(163, 230, 53, 0); }
    }
    @keyframes hintFadeIn {
      from { opacity: 0; transform: translateY(-50%) translateX(20px); }
      to { opacity: 1; transform: translateY(-50%) translateX(0); }
    }
    @keyframes arrowBounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(-8px); }
    }
    /* Hide zoom hint when already zoomed */
    .booklet-container.zoomed ~ .zoom-hint,
    .booklet-container.zoomed-max ~ .zoom-hint,
    .booklet-container.zoomed-ultra ~ .zoom-hint { display: none; }

    /* ========== MOBILE RESPONSIVE STYLES ========== */

    /* Tablets and small laptops */
    @media (max-width: 1024px) {
      .speech-bubble { max-width: 280px; }
      .info-panel { max-width: 280px; padding: 20px; }
    }

    /* Mobile landscape and small tablets */
    @media (max-width: 768px) {
      .booklet-nav { bottom: 20px; padding: 10px 20px; gap: 10px; }
      .booklet-nav button { width: 36px; height: 36px; }
      .booklet-close { top: 15px; right: 15px; width: 36px; height: 36px; }

      .audio-controls { top: 15px; right: 15px; gap: 8px; }
      .audio-btn { width: 38px; height: 38px; }

      #start-btn { padding: 14px 35px; font-size: 1rem; }
      #view-cv-btn { top: 15px; left: 15px; padding: 8px 18px; font-size: 0.85rem; }
      #page-overview { padding: 20px; }
      .overview-grid { gap: 15px; max-width: 700px; }

      .speech-bubble { max-width: 240px; padding: 12px 16px; font-size: 0.85rem; }
      .speech-bubble p { font-size: 0.85rem; }
      .speech-bubble.pos-center { max-width: 320px; bottom: 70px; }

      .info-panel { max-width: 240px; padding: 16px; }
      .info-panel h2 { font-size: 1.2rem; }
      .info-panel p { font-size: 0.8rem; }

      #lets-go-popup { font-size: 2rem; }

      #connect-now-btn { padding: 14px 30px; font-size: 1rem; }

      #contact-persistent { top: 70px; right: 15px; padding: 15px 18px; }
      #contact-persistent h4 { font-size: 0.9rem; }
      #contact-persistent .contact-item { font-size: 0.8rem; }

      .zoom-hint { right: 15px; }

      /* Speech bubbles - position to not overlap PDF on small tablets */
      .speech-bubble {
        max-width: 200px !important;
        font-size: 0.8rem;
      }
      .speech-bubble p { font-size: 0.8rem; }
      .speech-bubble.pos-left {
        left: 10px !important;
        right: auto !important;
      }
      .speech-bubble.pos-right {
        right: 10px !important;
        left: auto !important;
      }
      .speech-bubble.pos-center {
        bottom: 100px !important;
        max-width: 280px !important;
      }
    }

    /* Mobile portrait */
    @media (max-width: 480px) {
      /* Dynamic sizing handled by JS, just adjust padding */
      #pdf-booklet { padding: 10px; padding-bottom: 80px; }

      .booklet-nav { bottom: 15px; padding: 8px 15px; gap: 8px; border-radius: 30px; }
      .booklet-nav button { width: 32px; height: 32px; }
      .booklet-nav button svg { width: 16px; height: 16px; }
      .page-indicator { font-size: 0.8rem; min-width: 60px; }
      .booklet-close { top: 10px; right: 10px; width: 32px; height: 32px; }

      .audio-controls { top: 10px; right: 10px; gap: 6px; }
      .audio-btn { width: 34px; height: 34px; }
      .audio-btn svg { width: 16px; height: 16px; }

      #start-btn { padding: 12px 28px; font-size: 0.9rem; letter-spacing: 1px; }
      #view-cv-btn { top: 10px; left: 10px; padding: 6px 14px; font-size: 0.8rem; }
      #page-overview { padding: 15px; padding-top: 60px; }
      .overview-grid { grid-template-columns: repeat(2, 1fr); gap: 10px; max-width: 100%; }
      .overview-page-label { font-size: 0.7rem; padding: 4px 10px; }
      .overview-title { font-size: 1rem; top: 15px; }
      .overview-close { top: 12px; right: 12px; width: 35px; height: 35px; }

      /* Speech bubbles - position at bottom on mobile */
      .speech-bubble {
        max-width: calc(100vw - 40px) !important;
        left: 20px !important;
        right: 20px !important;
        bottom: 20px !important;
        top: auto !important;
        transform: none !important;
        padding: 12px 16px;
      }
      .speech-bubble.visible { transform: none !important; }
      .speech-bubble::before { display: none !important; }
      .speech-bubble p { font-size: 0.85rem; text-align: center; }
      .speech-bubble.pos-dynamic {
        left: 20px !important;
        right: 20px !important;
        max-width: none !important;
      }

      .info-panel { display: none; } /* Hide info panel on small mobile */

      /* Reposition zoom hint on mobile - below the nav */
      .zoom-hint {
        display: none; /* Hide on very small screens */
      }

      #lets-go-popup { font-size: 1.8rem; }

      #connect-now-btn {
        padding: 12px 25px;
        font-size: 0.95rem;
        width: calc(100vw - 60px);
        max-width: 280px;
        justify-content: center;
      }

      #contact-persistent {
        top: auto;
        bottom: 20px;
        right: 15px;
        left: 15px;
        padding: 12px 15px;
      }
      #contact-persistent h4 { font-size: 0.85rem; margin-bottom: 8px; }
      #contact-persistent .contact-item { font-size: 0.75rem; margin-bottom: 6px; gap: 8px; }
      #contact-persistent .contact-item svg { width: 14px; height: 14px; }

      .nav-container { bottom: 10px; padding: 8px 15px; gap: 8px; }
      .nav-btn { width: 10px; height: 10px; }

      .loading-box { width: 60px; height: 60px; }
      .loading-text { font-size: 1rem; }
      .loading-progress { width: 150px; }
    }

    /* Very small phones */
    @media (max-width: 360px) {
      .booklet-container { width: calc(100vw - 20px); }
      .pdf-page { width: calc(100vw - 40px); }

      #start-btn { padding: 10px 22px; font-size: 0.85rem; }
      .speech-bubble { padding: 10px 14px; }
      .speech-bubble p { font-size: 0.8rem; }

      #connect-now-btn { padding: 10px 20px; font-size: 0.9rem; }
    }

    /* Landscape orientation on mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .booklet-container { width: auto; height: 80vh; }
      .pdf-page { width: auto; height: calc(80vh - 40px); aspect-ratio: 0.74; }
      .page-stack { height: calc(80vh - 40px); }

      #pdf-booklet { top: 50%; }
      .booklet-nav { bottom: -55px; }
      .booklet-close { top: -35px; }

      .speech-bubble { bottom: 10px !important; max-width: 50vw !important; }

      #contact-persistent { top: 60px; bottom: auto; left: auto; right: 10px; width: auto; }
    }

    /* ========== SOCIAL & ACTION BUTTONS ========== */
    .action-buttons {
      position: fixed;
      bottom: 30px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transform: translateY(20px);
      transition: all 0.5s ease;
      align-items: flex-end;
    }
    .action-buttons.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .action-buttons .btn-row {
      display: flex;
      gap: 12px;
    }
    .action-btn {
      padding: 12px 20px;
      border-radius: 30px;
      background: var(--panel-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--panel-border);
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.9rem;
      font-weight: 500;
      text-decoration: none;
      transition: all 0.3s ease;
    }
    .action-btn:hover {
      border-color: var(--accent-color);
      background: rgba(163, 230, 53, 0.15);
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .action-btn svg { width: 18px; height: 18px; }
    .action-btn.linkedin { border-color: #0077b5; }
    .action-btn.linkedin:hover { background: rgba(0, 119, 181, 0.2); }
    .action-btn.download { background: linear-gradient(135deg, var(--accent-color), var(--accent-dark)); color: #0a0a0f; border: none; }
    .action-btn.download:hover { transform: translateY(-3px) scale(1.05); }
    .action-btn.connect { background: linear-gradient(135deg, var(--accent-color), var(--accent-dark)); color: #0a0a0f; border: none; }
    .action-btn.connect:hover { transform: translateY(-3px) scale(1.05); }
    .stacked-connect {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .stacked-connect.visible {
      display: flex !important;
      opacity: 1;
      transform: translateY(0);
    }

    /* ========== FLOATING ROBOT ASSISTANT ========== */
    #robot-assistant {
      position: fixed;
      bottom: 100px;
      left: 40px;
      z-index: 50;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.8s ease;
    }
    #robot-assistant.visible { opacity: 1; }

    .robot-container {
      position: relative;
      width: 80px;
      height: 120px;
      animation: robotFloat 3s ease-in-out infinite;
    }

    /* Robot Head */
    .robot-head {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 45px;
    }

    .robot-antenna {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 3px;
      height: 12px;
      background: linear-gradient(180deg, #a3e635, #65a30d);
      border-radius: 2px;
    }

    .antenna-ball {
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: #a3e635;
      border-radius: 50%;
      box-shadow: 0 0 10px #a3e635, 0 0 20px rgba(163, 230, 53, 0.5);
      animation: antennaPulse 1.5s ease-in-out infinite;
    }

    .robot-face {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 46px;
      height: 38px;
      background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
      border-radius: 12px 12px 8px 8px;
      border: 2px solid #3a3a4e;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5), 0 4px 15px rgba(0,0,0,0.3);
    }

    .robot-eye {
      position: absolute;
      top: 10px;
      width: 12px;
      height: 12px;
      background: #0a0a15;
      border-radius: 50%;
      overflow: hidden;
    }
    .robot-eye.left { left: 8px; }
    .robot-eye.right { right: 8px; }

    .robot-eye::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle at 30% 30%, #a3e635, #4a7c10);
      border-radius: 50%;
      animation: eyeGlow 2s ease-in-out infinite;
    }

    .robot-mouth {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 4px;
      background: #a3e635;
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(163, 230, 53, 0.6);
      animation: mouthTalk 0.3s ease-in-out infinite;
    }

    /* Robot Body */
    .robot-body {
      position: absolute;
      top: 48px;
      left: 50%;
      transform: translateX(-50%);
      width: 44px;
      height: 50px;
    }

    .robot-chest {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 45px;
      background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
      border-radius: 8px 8px 12px 12px;
      border: 2px solid #3a3a4e;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
    }

    .robot-core {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 16px;
      background: radial-gradient(circle, #a3e635 0%, #4a7c10 70%, transparent 100%);
      border-radius: 50%;
      box-shadow: 0 0 15px #a3e635, 0 0 30px rgba(163, 230, 53, 0.4);
      animation: corePulse 2s ease-in-out infinite;
    }

    .robot-arm {
      position: absolute;
      top: 5px;
      width: 8px;
      height: 30px;
      background: linear-gradient(180deg, #3a3a4e, #2a2a3e);
      border-radius: 4px;
    }
    .robot-arm.left {
      left: -6px;
      transform-origin: top center;
      animation: armWaveLeft 2s ease-in-out infinite;
    }
    .robot-arm.right {
      right: -6px;
      transform-origin: top center;
      animation: armWaveRight 2s ease-in-out infinite 0.5s;
    }

    /* Shadow and Effects */
    .robot-shadow {
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 12px;
      background: radial-gradient(ellipse, rgba(0,0,0,0.4) 0%, transparent 70%);
      animation: shadowPulse 3s ease-in-out infinite;
    }

    .robot-thrust {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      height: 20px;
    }

    .thrust-particle {
      position: absolute;
      bottom: 0;
      width: 4px;
      height: 4px;
      background: #a3e635;
      border-radius: 50%;
      animation: thrustParticle 0.8s ease-out infinite;
    }
    .thrust-particle:nth-child(1) { left: 5px; animation-delay: 0s; }
    .thrust-particle:nth-child(2) { left: 13px; animation-delay: 0.2s; }
    .thrust-particle:nth-child(3) { left: 21px; animation-delay: 0.4s; }

    /* Robot Message Bubble */
    .robot-message {
      position: absolute;
      top: -10px;
      left: 90px;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(10px);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(163, 230, 53, 0.4);
      white-space: normal;
      min-width: 140px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.85rem;
      color: #a3e635;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4), 0 0 15px rgba(163, 230, 53, 0.1);
      opacity: 0;
      transform: translateX(-10px);
      transition: opacity 0.4s ease, transform 0.4s ease;
    }
    .robot-message::before {
      content: '';
      position: absolute;
      left: -8px;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: rgba(163, 230, 53, 0.4);
    }
    #robot-assistant.visible .robot-message {
      opacity: 1;
      transform: translateX(0);
      animation: messageShow 4s ease-in-out infinite;
    }
    #robot-assistant.visible .robot-message.static {
      animation: none;
      opacity: 1;
      transform: translateX(0);
    }
    #robot-assistant.interactive {
      pointer-events: auto;
      cursor: pointer;
      z-index: 200;
    }
    #robot-assistant.interactive .robot-message {
      pointer-events: auto;
    }

    /* Help options styling */
    .help-text {
      display: block;
      margin-bottom: 8px;
    }
    .help-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
      animation: fadeInOptions 0.3s ease-out;
    }
    @keyframes fadeInOptions {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .help-option {
      background: rgba(163, 230, 53, 0.15);
      border: 1px solid rgba(163, 230, 53, 0.4);
      color: #a3e635;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-family: 'Space Grotesk', sans-serif;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }
    .help-option:hover {
      background: rgba(163, 230, 53, 0.3);
      transform: translateX(3px);
    }

    /* Robot Animations */
    @keyframes robotFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes antennaPulse {
      0%, 100% { box-shadow: 0 0 10px #a3e635, 0 0 20px rgba(163, 230, 53, 0.5); }
      50% { box-shadow: 0 0 15px #a3e635, 0 0 30px rgba(163, 230, 53, 0.8); }
    }

    @keyframes eyeGlow {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes mouthTalk {
      0%, 100% { width: 16px; }
      50% { width: 12px; }
    }

    @keyframes corePulse {
      0%, 100% { box-shadow: 0 0 15px #a3e635, 0 0 30px rgba(163, 230, 53, 0.4); transform: translateX(-50%) scale(1); }
      50% { box-shadow: 0 0 20px #a3e635, 0 0 40px rgba(163, 230, 53, 0.6); transform: translateX(-50%) scale(1.1); }
    }

    @keyframes armWaveLeft {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-15deg); }
      75% { transform: rotate(10deg); }
    }

    @keyframes armWaveRight {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(15deg); }
      75% { transform: rotate(-10deg); }
    }

    @keyframes shadowPulse {
      0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.4; }
      50% { transform: translateX(-50%) scale(0.8); opacity: 0.6; }
    }

    @keyframes thrustParticle {
      0% { transform: translateY(0) scale(1); opacity: 0.8; }
      100% { transform: translateY(25px) scale(0); opacity: 0; }
    }

    @keyframes messageShow {
      0%, 15%, 85%, 100% { opacity: 0; transform: translateX(-10px); }
      25%, 75% { opacity: 1; transform: translateX(0); }
    }

    @media (max-width: 768px) {
      .theme-toggle { top: 15px; left: 15px; }
      .action-buttons { bottom: 20px; right: 20px; }
      .action-buttons .btn-row { flex-direction: column; }
      .action-btn { padding: 10px 16px; font-size: 0.85rem; }
      #robot-assistant { display: none; }
    }

    @media (max-width: 480px) {
      .action-buttons { bottom: 15px; right: 15px; left: 15px; align-items: center; }
      .action-buttons .btn-row { flex-direction: row; justify-content: center; }
      .action-btn span { display: none; }
      .action-btn { padding: 12px; border-radius: 50%; }
      .stacked-connect { border-radius: 50%; padding: 12px; }
    }
  </style>
</head>
<body>
  <canvas id="neural-bg"></canvas>
  <div id="canvas-container"></div>

  <!-- Floating Robot Assistant -->
  <div id="robot-assistant">
    <div class="robot-container">
      <!-- Robot Head -->
      <div class="robot-head">
        <div class="robot-antenna">
          <div class="antenna-ball"></div>
        </div>
        <div class="robot-face">
          <div class="robot-eye left"></div>
          <div class="robot-eye right"></div>
          <div class="robot-mouth"></div>
        </div>
      </div>
      <!-- Robot Body -->
      <div class="robot-body">
        <div class="robot-chest">
          <div class="robot-core"></div>
        </div>
        <div class="robot-arm left"></div>
        <div class="robot-arm right"></div>
      </div>
      <!-- Hover Effect -->
      <div class="robot-shadow"></div>
      <div class="robot-thrust">
        <div class="thrust-particle"></div>
        <div class="thrust-particle"></div>
        <div class="thrust-particle"></div>
      </div>
    </div>
    <div class="robot-message" id="holo-message">
      <span class="message-text">Welcome!</span>
    </div>
  </div>

  <!-- Action Buttons (LinkedIn, Download, and stacked Connect) -->
  <div class="action-buttons" id="action-buttons">
    <a class="action-btn connect stacked-connect" id="stacked-connect-btn" href="mailto:linton.evans@outlook.com?subject=Let's%20Connect%20-%20From%20Your%20Portfolio" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
        <polyline points="22,6 12,13 2,6"></polyline>
      </svg>
      <span>Connect Now</span>
    </a>
    <div class="btn-row">
      <a class="action-btn linkedin" href="https://www.linkedin.com/sharing/share-offsite/?url=https://vteckz.github.io/cv/" target="_blank" rel="noopener">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
        </svg>
        <span>Share</span>
      </a>
      <button class="action-btn download" id="download-cv-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        <span>Download CV</span>
      </button>
    </div>
  </div>

  <div id="loading-screen">
    <div class="loading-box"></div>
    <div class="loading-text">LOADING PORTFOLIO</div>
    <div class="loading-progress"><div class="loading-progress-bar" id="progress-bar"></div></div>
  </div>

  <div id="lets-go-popup">Let's Go! </div>

  <a id="connect-now-btn" href="mailto:linton.evans@outlook.com?subject=Let's%20Connect%20-%20From%20Your%20Portfolio">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
      <polyline points="22,6 12,13 2,6"></polyline>
    </svg>
    Connect Now
  </a>

  <div id="contact-persistent">
    <h4>
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
      </svg>
      Get In Touch
    </h4>
    <div class="contact-item">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
        <polyline points="22,6 12,13 2,6"></polyline>
      </svg>
      <a href="mailto:linton.evans@outlook.com">linton.evans@outlook.com</a>
    </div>
    <div class="contact-item">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
      </svg>
      <a href="tel:+64-21-939-505">+64-21-939-505</a>
    </div>
  </div>

  <div id="pdf-booklet">
    <div class="booklet-container">
      <div class="page-stack">
        <div class="pdf-page current" id="page-current"><canvas id="canvas-current"></canvas></div>
        <div class="pdf-page next" id="page-next"><canvas id="canvas-next"></canvas></div>
        <div class="page-curl-container" id="curl-container"></div>
      </div>
    </div>
    <div class="zoom-hint" id="zoom-hint">
      <svg class="arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
      <span class="hint-text"><strong>Click page</strong> to zoom in</span>
    </div>
    <button class="booklet-close" id="close-booklet"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
    <div class="booklet-nav">
      <button id="prev-page"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
      <span class="page-indicator" id="page-indicator">1 / 4</span>
      <button id="next-page"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
      <button id="zoom-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg></button>
    </div>
  </div>

  <div id="ui-overlay">
    <button id="start-btn">Open My CV</button>
    <button id="view-cv-btn"> All Pages</button>

  <!-- Page Overview Grid -->
  <div id="page-overview">
    <button class="overview-close"></button>
    <span class="overview-title">Select a Page</span>
    <div class="overview-grid">
      <div class="overview-page" data-page="1">
        <canvas id="overview-canvas-1"></canvas>
        <span class="overview-page-label">Page 1</span>
      </div>
      <div class="overview-page" data-page="2">
        <canvas id="overview-canvas-2"></canvas>
        <span class="overview-page-label">Page 2</span>
      </div>
      <div class="overview-page" data-page="3">
        <canvas id="overview-canvas-3"></canvas>
        <span class="overview-page-label">Page 3</span>
      </div>
      <div class="overview-page" data-page="4">
        <canvas id="overview-canvas-4"></canvas>
        <span class="overview-page-label">Page 4</span>
      </div>
    </div>
  </div>
    <div class="audio-controls">
      <button class="audio-btn" id="skip-btn" title="Skip">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="5 4 15 12 5 20 5 4"></polygon>
          <line x1="19" y1="5" x2="19" y2="19"></line>
        </svg>
      </button>
    </div>
    <div class="info-panel pos-top-left" id="info-panel">
      <h2 id="panel-title"></h2>
      <h3 id="panel-subtitle"></h3>
      <p id="panel-content"></p>
    </div>
    <div class="nav-container" id="nav-container">
      <button class="nav-btn active" data-section="0"></button>
      <button class="nav-btn" data-section="1"></button>
      <button class="nav-btn" data-section="2"></button>
      <button class="nav-btn" data-section="3"></button>
      <button class="nav-btn" data-section="4"></button>
      <button class="nav-btn" data-section="5"></button>
    </div>
    <div class="speech-bubble pos-top-right" id="speech-bubble"><p id="speech-text"></p></div>

  </div>

  <!-- Neural Network Background Script - Runs First -->
  <script>
    (function() {
      const canvas = document.getElementById('neural-bg');
      const ctx = canvas.getContext('2d');
      const nodes = [];
      const connections = [];
      let width, height, time = 0;

      // Detect Firefox for performance optimization
      const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
      let lastFrameTime = 0;
      const targetFPS = isFirefox ? 30 : 60; // Lower FPS for Firefox
      const frameInterval = 1000 / targetFPS;

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        initNodes();
      }

      function initNodes() {
        nodes.length = 0;
        connections.length = 0;
        // Fewer nodes for Firefox
        const divisor = isFirefox ? 25000 : 15000;
        const count = Math.floor((width * height) / divisor);

        for (let i = 0; i < count; i++) {
          nodes.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 2 + 1,
            pulse: Math.random() * Math.PI * 2
          });
        }
      }

      function draw(currentTime) {
        // Frame rate limiting
        const deltaTime = currentTime - lastFrameTime;
        if (deltaTime < frameInterval) {
          requestAnimationFrame(draw);
          return;
        }

        // Calculate speed multiplier to normalize movement across different frame rates
        const speedMultiplier = deltaTime / 16.67; // 16.67ms = 60fps baseline
        lastFrameTime = currentTime;

        time += 0.01 * speedMultiplier;

        // Check if light mode
        // Dark gradient background
        const grad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height) * 0.8);
        grad.addColorStop(0, '#0f0f1a');
        grad.addColorStop(1, '#050508');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        // Update and draw nodes
        nodes.forEach((node, i) => {
          // Move (adjusted for frame rate)
          node.x += node.vx * speedMultiplier;
          node.y += node.vy * speedMultiplier;

          // Bounce
          if (node.x < 0 || node.x > width) node.vx *= -1;
          if (node.y < 0 || node.y > height) node.vy *= -1;

          // Keep in bounds
          node.x = Math.max(0, Math.min(width, node.x));
          node.y = Math.max(0, Math.min(height, node.y));

          // Draw connections to nearby nodes
          for (let j = i + 1; j < nodes.length; j++) {
            const other = nodes[j];
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 150) {
              const alpha = (1 - dist / 150) * 0.3;
              ctx.beginPath();
              ctx.moveTo(node.x, node.y);
              ctx.lineTo(other.x, other.y);
              ctx.strokeStyle = `rgba(163, 230, 53, ${alpha})`;
              ctx.lineWidth = 0.5;
              ctx.stroke();
            }
          }

          // Draw node with pulse
          const pulse = Math.sin(time * 2 + node.pulse) * 0.5 + 0.5;
          const glowRadius = node.radius * (2 + pulse);

          // Glow
          const nodeGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, glowRadius * 3);
          nodeGrad.addColorStop(0, `rgba(163, 230, 53, ${0.3 + pulse * 0.2})`);
          nodeGrad.addColorStop(1, 'rgba(163, 230, 53, 0)');
          ctx.fillStyle = nodeGrad;
          ctx.beginPath();
          ctx.arc(node.x, node.y, glowRadius * 3, 0, Math.PI * 2);
          ctx.fill();

          // Core
          ctx.fillStyle = `rgba(163, 230, 53, ${0.6 + pulse * 0.4})`;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        requestAnimationFrame(draw);
      }

      resize();
      window.addEventListener('resize', resize);
      requestAnimationFrame(draw);
    })();
  </script>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // CV Data
    const cvData = {
      personal: { name: "Linton Evans", title: "Technical Specialist", email: "linton.evans@outlook.com", phone: "+64-21-939-505", location: "Auckland, New Zealand", noticePeriod: "1-2 Weeks" },
      shortSummary: "Technical Specialist with 17+ years bridging deep technical expertise with practical business execution.",
      experience: [
        { title: "Owner / Operator", company: "E & E Traders Limited", period: "2019 - Present" },
        { title: "Product Architect - UC", company: "Spark New Zealand", period: "2014 - 2020" },
        { title: "UC Manager", company: "Pure IP Limited", period: "2014" },
        { title: "APAC IT Network Manager", company: "Zeacom / Enghouse", period: "2011 - 2014" }
      ],
      skills: { technical: ["JavaScript", "Python", "REST APIs", "Three.js"], platforms: ["Microsoft Teams", "Azure", "AWS"], marketing: ["Google Ads", "GA4", "SEO"] },
      education: [{ degree: "Bachelor of Computing Sciences", institution: "Unitec Institute of Technology" }],
      speeches: {
        welcome: [
          "G'day! I'm Linton Evans, a Technical Solutions Architect based in Auckland.",
          "Welcome to my interactive portfolio - let me show you what I can do!"
        ],
        about: [
          "17+ years bridging deep technical expertise with practical business execution.",
          "Full-stack development: from frontend interfaces to backend APIs and databases.",
          "Multi-platform integration specialist - connecting systems that don't want to talk.",
          "Web development expert: modern JavaScript, responsive design, and performance optimization."
        ],
        experience: [
          "Product Architect at Spark NZ - designed unified communications solutions at scale.",
          "Built and operated my own e-commerce business with custom integrations.",
          "APAC IT Network Manager - managed infrastructure across multiple countries.",
          "Delivered enterprise solutions for Microsoft Teams, Azure, and cloud platforms."
        ],
        skills: [
          "Full-stack app development: JavaScript, Python, Node.js, REST APIs.",
          "Cloud architecture: Azure, AWS, serverless functions, and microservices.",
          "API development & integration: connecting CRMs, ERPs, and third-party services.",
          "E-commerce: BigCommerce, Shopify, store customizations, payment gateway integration, API-based inventory systems.",
          "Data & analytics: GA4, Google Ads, SEO optimization, conversion tracking."
        ],
        education: [
          "Bachelor of Computing Sciences - structured foundation in system networking and interop.",
          "Microsoft certified: Teams, Azure, and cloud technologies.",
          "Continuous learner: always exploring new frameworks and tools.",
          "AI evangelist: fine-tuning LLMs, prompt engineering, and integrating AI into real-world workflows."
        ],
        contact: [
          "Available with 1-2 weeks notice - ready for new challenges!",
          "Let's connect: linton.evans@outlook.com or +64-21-939-505"
        ]
      }
    };

    // PDF Viewer - Single Page with Turn Animation
    class PDFBooklet {
      constructor() {
        this.pdfDoc = null;
        this.currentPage = 1;
        this.totalPages = 0;
        this.zoomLevel = 0;
        this.isAnimating = false;
        this.container = document.getElementById('pdf-booklet');
        this.bookletContainer = this.container.querySelector('.booklet-container');
        this.pageCurrent = document.getElementById('page-current');
        this.pageNext = document.getElementById('page-next');
        this.canvasCurrent = document.getElementById('canvas-current');
        this.canvasNext = document.getElementById('canvas-next');
        this.pageIndicator = document.getElementById('page-indicator');
        this.curlContainer = document.getElementById('curl-container');

        // Paper curl configuration
        this.numStrips = 12; // Number of vertical strips for curl effect
        this.pageWidth = 430;
        this.pageHeight = 580;
        this.animationDuration = 1400; // ms

        // Page aspect ratio (A4-ish)
        this.pageAspect = 580 / 430; // height / width

        // Scroll state for zoomed view
        this.scrollOffset = 0;
        this.scrollVelocity = 0;
        this.maxScroll = 200;
        this.isDragging = false;
        this.lastTouchY = 0;

        document.getElementById('prev-page').addEventListener('click', () => this.prevPage());
        document.getElementById('next-page').addEventListener('click', () => this.nextPage());
        document.getElementById('close-booklet').addEventListener('click', () => this.hide());
        document.getElementById('view-cv-btn').addEventListener('click', () => this.showPageOverview());
        document.getElementById('zoom-btn').addEventListener('click', () => this.toggleZoom());
        this.pageCurrent.addEventListener('click', () => this.toggleZoom());

        // Page overview handlers
        document.querySelector('.overview-close').addEventListener('click', () => this.hidePageOverview());
        document.querySelectorAll('.overview-page').forEach(page => {
          page.addEventListener('click', () => {
            const pageNum = parseInt(page.dataset.page);
            this.hidePageOverview();
            this.show();
            this.turnToPage(pageNum);
          });
        });

        // Setup scroll handlers
        this.setupScrollHandlers();

        // Calculate and set dynamic sizes
        this.calculateSizes();
        window.addEventListener('resize', () => this.calculateSizes());
      }

      async showPageOverview() {
        const overview = document.getElementById('page-overview');
        const centerConnectBtn = document.getElementById('connect-now-btn');
        const stackedConnectBtn = document.getElementById('stacked-connect-btn');
        const actionButtons = document.getElementById('action-buttons');

        // If Connect Now button is visible (center), animate it to stack
        if (centerConnectBtn && centerConnectBtn.classList.contains('visible')) {
          // Hide center button
          centerConnectBtn.style.opacity = '0';
          centerConnectBtn.style.pointerEvents = 'none';

          // Show stacked button with action buttons
          if (!actionButtons.classList.contains('visible')) {
            actionButtons.classList.add('visible');
          }
          stackedConnectBtn.style.display = 'flex';
          setTimeout(() => {
            stackedConnectBtn.classList.add('visible');
          }, 50);
        }

        // Render all pages to overview canvases
        for (let i = 1; i <= Math.min(4, this.totalPages); i++) {
          const canvas = document.getElementById(`overview-canvas-${i}`);
          if (canvas && this.pdfDoc) {
            const page = await this.pdfDoc.getPage(i);
            const vp = page.getViewport({ scale: 1 });
            const scale = 300 / vp.width; // Scale to fit overview
            const scaledVp = page.getViewport({ scale });
            canvas.width = scaledVp.width;
            canvas.height = scaledVp.height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            await page.render({ canvasContext: ctx, viewport: scaledVp }).promise;
          }
        }

        // Hide any pages beyond what we have
        for (let i = this.totalPages + 1; i <= 4; i++) {
          const pageEl = document.querySelector(`.overview-page[data-page="${i}"]`);
          if (pageEl) pageEl.style.display = 'none';
        }

        overview.classList.add('visible');
      }

      hidePageOverview() {
        document.getElementById('page-overview').classList.remove('visible');
      }

      calculateSizes() {
        // Get available viewport space (accounting for nav bar at bottom)
        const navHeight = 100; // Space for bottom nav
        const padding = window.innerWidth <= 480 ? 20 : 60; // Less padding on mobile
        const availHeight = window.innerHeight - navHeight - padding;
        const availWidth = window.innerWidth - padding * 2;
        const isMobile = window.innerWidth <= 480;

        // Calculate base size to fit viewport while maintaining aspect ratio
        let baseWidth, baseHeight;
        if (availWidth / availHeight > 1 / this.pageAspect) {
          // Height constrained
          baseHeight = Math.min(availHeight * (isMobile ? 0.7 : 0.85), 750);
          baseWidth = baseHeight / this.pageAspect;
        } else {
          // Width constrained
          baseWidth = Math.min(availWidth * (isMobile ? 0.9 : 0.85), 550);
          baseHeight = baseWidth * this.pageAspect;
        }

        // Detect if desktop or mobile for different zoom strategies
        const isDesktop = availWidth >= 1024;

        // Set CSS custom properties for base size
        const root = document.documentElement;
        root.style.setProperty('--booklet-width', `${baseWidth}px`);
        root.style.setProperty('--booklet-height', `${baseHeight}px`);

        // Set zoom scale factors - use transform: scale() for actual zooming
        // Desktop gets larger zoom levels since screens are bigger
        if (isDesktop) {
          root.style.setProperty('--zoom-scale-1', '1.4');
          root.style.setProperty('--zoom-scale-2', '1.9');
          root.style.setProperty('--zoom-scale-3', '2.4');
        } else {
          // Mobile - more conservative zoom
          root.style.setProperty('--zoom-scale-1', '1.2');
          root.style.setProperty('--zoom-scale-2', '1.5');
          root.style.setProperty('--zoom-scale-3', '1.8');
        }

        // Update internal dimensions for curl calculations
        this.pageWidth = baseWidth;
        this.pageHeight = baseHeight;
      }

      setupScrollHandlers() {
        // Mouse wheel scrolling
        this.container.addEventListener('wheel', (e) => {
          if (this.zoomLevel === 0) return;
          e.preventDefault();
          // Add to velocity for momentum feel
          this.scrollVelocity += e.deltaY * 0.3;
          this.scrollOffset += e.deltaY * 0.5;
          this.clampAndApplyScroll();
        }, { passive: false });

        // Touch scrolling and pinch-to-zoom
        this.initialPinchDistance = 0;
        this.isPinching = false;
        this.lastPinchTime = 0;
        this.tempZoomScale = 1;  // For hold-to-zoom beyond level 3
        this.tempZoomActive = false;
        this.pinchStartDistance = 0;  // Track distance when temp zoom starts
        this.tempPanX = 0;  // Temporary pan offset X
        this.tempPanY = 0;  // Temporary pan offset Y
        this.lastPinchCenterX = 0;  // Last pinch center for panning
        this.lastPinchCenterY = 0;

        // Helper to get pinch center point
        const getPinchCenter = (touches) => {
          return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
          };
        };

        // Use document-level listeners for more reliable touch capture on Samsung Internet
        const handleTouchStart = (e) => {
          // Check if touch is within our container
          if (!this.container.contains(e.target) && e.target !== this.container) return;

          if (e.touches.length === 2) {
            // Start pinch zoom - prevent ALL default behavior
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            this.isPinching = true;
            this.isDragging = false;
            this.initialPinchDistance = this.getPinchDistance(e.touches);
            this.lastPinchTime = Date.now();

            // Track pinch center for panning
            const center = getPinchCenter(e.touches);
            this.lastPinchCenterX = center.x;
            this.lastPinchCenterY = center.y;

            // If already at max zoom, prepare for temp zoom
            if (this.zoomLevel === 3) {
              this.pinchStartDistance = this.initialPinchDistance;
            }
          } else if (e.touches.length === 1) {
            // Single touch - scroll only when zoomed
            if (this.zoomLevel === 0) return;
            this.isDragging = true;
            this.lastTouchY = e.touches[0].clientY;
            this.scrollVelocity = 0;
          }
        };

        const handleTouchMove = (e) => {
          // Check if touch is within our container
          if (!this.container.contains(e.target) && e.target !== this.container) return;

          if (e.touches.length === 2) {
            // Handle pinch zoom - ALWAYS prevent default for 2-finger touch
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            // Get current pinch center for panning
            const center = getPinchCenter(e.touches);

            if (!this.isPinching) {
              // Just started second finger
              this.isPinching = true;
              this.isDragging = false;
              this.initialPinchDistance = this.getPinchDistance(e.touches);
              this.lastPinchCenterX = center.x;
              this.lastPinchCenterY = center.y;
              if (this.zoomLevel === 3) {
                this.pinchStartDistance = this.initialPinchDistance;
              }
              return;
            }

            const currentDistance = this.getPinchDistance(e.touches);
            const scale = currentDistance / this.initialPinchDistance;

            // Very low thresholds for Samsung Internet - just 5% change triggers zoom
            const now = Date.now();
            const timeSinceLastPinch = now - this.lastPinchTime;

            // If at max zoom level (3), apply temporary transform zoom + panning
            if (this.zoomLevel === 3 && (scale > 1.0 || this.tempZoomActive)) {
              // Calculate temp zoom scale (max 2.5x additional zoom)
              const tempScale = Math.max(1.0, Math.min(scale, 2.5));
              this.tempZoomScale = tempScale;
              this.tempZoomActive = true;

              // Calculate pan offset based on finger movement
              const panDeltaX = center.x - this.lastPinchCenterX;
              const panDeltaY = center.y - this.lastPinchCenterY;
              this.tempPanX += panDeltaX;
              this.tempPanY += panDeltaY;

              // Update last center
              this.lastPinchCenterX = center.x;
              this.lastPinchCenterY = center.y;

              // Apply transform with scale and pan
              this.bookletContainer.classList.add('temp-zoom');
              this.bookletContainer.classList.remove('temp-zoom-release');
              this.bookletContainer.style.transform = `translate(${this.tempPanX}px, ${this.tempPanY}px) scale(${tempScale})`;
            }
            // Normal zoom level changes
            else if (timeSinceLastPinch > 300) {
              if (scale > 1.05 && this.zoomLevel < 3) {
                // Zoom in
                this.zoomLevel++;
                this.applyZoomLevel();
                this.initialPinchDistance = currentDistance;
                this.lastPinchTime = now;

                // If just reached level 3, prepare for temp zoom
                if (this.zoomLevel === 3) {
                  this.pinchStartDistance = currentDistance;
                  this.lastPinchCenterX = center.x;
                  this.lastPinchCenterY = center.y;
                }
              } else if (scale < 0.95 && this.zoomLevel > 0) {
                // Zoom out (also resets temp zoom)
                if (this.tempZoomActive) {
                  this.resetTempZoom();
                }
                this.zoomLevel--;
                this.applyZoomLevel();
                this.initialPinchDistance = currentDistance;
                this.lastPinchTime = now;
              }
            }
          } else if (e.touches.length === 1 && this.isDragging && !this.isPinching) {
            // Single touch scroll
            if (this.zoomLevel === 0) return;
            e.preventDefault();
            const touchY = e.touches[0].clientY;
            const delta = this.lastTouchY - touchY;
            this.scrollVelocity = delta;
            this.scrollOffset += delta;
            this.lastTouchY = touchY;
            this.applyScroll();
          }
        };

        const handleTouchEnd = (e) => {
          if (e.touches.length === 0) {
            this.isPinching = false;

            // Reset temporary zoom with bounce animation
            if (this.tempZoomActive) {
              this.resetTempZoom();
            }

            if (this.isDragging) {
              this.isDragging = false;
              this.animateBounceBack();
            }
          } else if (e.touches.length === 1) {
            // Went from 2 fingers to 1 - reset to scroll mode
            this.isPinching = false;

            // Reset temporary zoom
            if (this.tempZoomActive) {
              this.resetTempZoom();
            }

            if (this.zoomLevel > 0) {
              this.isDragging = true;
              this.lastTouchY = e.touches[0].clientY;
              this.scrollVelocity = 0;
            }
          }
        };

        // Add listeners to both container AND document for better capture
        this.container.addEventListener('touchstart', handleTouchStart, { passive: false, capture: true });
        this.container.addEventListener('touchmove', handleTouchMove, { passive: false, capture: true });
        this.container.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Also add document-level listeners as fallback for Samsung Internet
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Mouse drag scrolling
        this.container.addEventListener('mousedown', (e) => {
          if (this.zoomLevel === 0) return;
          this.isDragging = true;
          this.lastTouchY = e.clientY;
          this.scrollVelocity = 0;
        });

        window.addEventListener('mousemove', (e) => {
          if (this.zoomLevel === 0 || !this.isDragging) return;
          const delta = this.lastTouchY - e.clientY;
          this.scrollVelocity = delta;
          this.scrollOffset += delta;
          this.lastTouchY = e.clientY;
          this.applyScroll();
        });

        window.addEventListener('mouseup', () => {
          if (this.isDragging) {
            this.isDragging = false;
            this.animateBounceBack();
          }
        });
      }

      applyScroll() {
        this.bookletContainer.style.setProperty('--scroll-offset', `${-this.scrollOffset}px`);
      }

      clampAndApplyScroll() {
        // Allow some overscroll for bounce effect
        const overscrollLimit = this.maxScroll * 1.3;
        this.scrollOffset = Math.max(-overscrollLimit, Math.min(overscrollLimit, this.scrollOffset));
        this.applyScroll();
        this.animateBounceBack();
      }

      animateBounceBack() {
        // Cancel any existing animation
        if (this.bounceAnimationId) {
          cancelAnimationFrame(this.bounceAnimationId);
        }

        const animate = () => {
          if (this.isDragging) return;

          // Apply momentum
          this.scrollOffset += this.scrollVelocity * 0.4;
          this.scrollVelocity *= 0.88; // Friction

          // Bounce back if beyond limits with elastic effect
          if (this.scrollOffset > this.maxScroll) {
            const overshoot = this.scrollOffset - this.maxScroll;
            this.scrollOffset -= overshoot * 0.2;
            this.scrollVelocity *= 0.6;
          } else if (this.scrollOffset < -this.maxScroll) {
            const overshoot = -this.maxScroll - this.scrollOffset;
            this.scrollOffset += overshoot * 0.2;
            this.scrollVelocity *= 0.6;
          }

          this.applyScroll();

          // Continue animation if still moving or bouncing back
          const isMoving = Math.abs(this.scrollVelocity) > 0.3;
          const isBouncing = Math.abs(this.scrollOffset) > this.maxScroll;

          if (isMoving || isBouncing) {
            this.bounceAnimationId = requestAnimationFrame(animate);
          } else {
            this.bounceAnimationId = null;
          }
        };
        this.bounceAnimationId = requestAnimationFrame(animate);
      }

      getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      applyZoomLevel() {
        this.bookletContainer.classList.remove('zoomed', 'zoomed-max', 'zoomed-ultra');
        if (this.zoomLevel === 1) this.bookletContainer.classList.add('zoomed');
        else if (this.zoomLevel === 2) this.bookletContainer.classList.add('zoomed-max');
        else if (this.zoomLevel === 3) this.bookletContainer.classList.add('zoomed-ultra');

        // Hide zoom hint when user zooms
        if (this.zoomLevel > 0) {
          document.getElementById('zoom-hint').classList.remove('visible');
        }

        // Reset scroll when exiting zoom
        if (this.zoomLevel === 0) {
          this.scrollOffset = 0;
          this.applyScroll();
        }

        // Update zoom button state
        const zoomBtn = document.getElementById('zoom-btn');
        zoomBtn.classList.toggle('active', this.zoomLevel > 0);
      }

      toggleZoom() {
        this.zoomLevel = (this.zoomLevel + 1) % 4;
        this.applyZoomLevel();
      }

      resetTempZoom() {
        // Animate back to normal scale and position with bounce
        this.bookletContainer.classList.remove('temp-zoom');
        this.bookletContainer.classList.add('temp-zoom-release');
        this.bookletContainer.style.transform = 'translate(0px, 0px) scale(1)';

        // Clean up after animation
        setTimeout(() => {
          this.bookletContainer.classList.remove('temp-zoom-release');
          this.bookletContainer.style.transform = '';
          this.tempZoomActive = false;
          this.tempZoomScale = 1;
          this.tempPanX = 0;
          this.tempPanY = 0;
        }, 300);
      }

      async loadPDF(url) {
        try {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
          this.pdfDoc = await pdfjsLib.getDocument(url).promise;
          this.totalPages = this.pdfDoc.numPages;
          await this.renderPage(1, this.canvasCurrent);
          this.updateIndicator();
          return true;
        } catch (e) { return false; }
      }

      async renderPage(pageNum, canvas) {
        if (pageNum < 1 || pageNum > this.totalPages) {
          const ctx = canvas.getContext('2d');
          canvas.width = 430; canvas.height = 580;
          ctx.fillStyle = '#f5f5f5';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          return;
        }
        const page = await this.pdfDoc.getPage(pageNum);
        const vp = page.getViewport({ scale: 1 });
        const scale = Math.min(430 / vp.width, 580 / vp.height) * 3.5;
        const scaledVp = page.getViewport({ scale });
        canvas.width = scaledVp.width;
        canvas.height = scaledVp.height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        await page.render({ canvasContext: ctx, viewport: scaledVp }).promise;
      }

      updateIndicator() {
        this.pageIndicator.textContent = `${this.currentPage} / ${this.totalPages}`;
        document.getElementById('prev-page').disabled = this.currentPage <= 1;
        document.getElementById('next-page').disabled = this.currentPage >= this.totalPages;
      }

      // Create the curling page element from current page canvas
      createCurlPage(sourceCanvas, goingForward) {
        this.curlContainer.innerHTML = '';

        // Create shadow element
        const shadow = document.createElement('div');
        shadow.className = 'curl-shadow';
        this.curlContainer.appendChild(shadow);

        // Create the page that will curl
        const curlPage = document.createElement('div');
        curlPage.className = 'curl-page';

        // Set transform origin based on direction
        if (goingForward) {
          curlPage.style.transformOrigin = 'bottom left';
        } else {
          curlPage.style.transformOrigin = 'bottom right';
        }

        // Create canvas copy
        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = sourceCanvas.width;
        pageCanvas.height = sourceCanvas.height;
        pageCanvas.getContext('2d').drawImage(sourceCanvas, 0, 0);

        // Create gradient overlay for depth effect
        const gradient = document.createElement('div');
        gradient.className = 'curl-gradient';

        curlPage.appendChild(pageCanvas);
        curlPage.appendChild(gradient);
        this.curlContainer.appendChild(curlPage);

        return { curlPage, shadow, gradient };
      }

      // Smooth easing functions
      easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      easeOutQuart(t) {
        return 1 - Math.pow(1 - t, 4);
      }

      // Animate the corner peel page curl effect
      async animateCurl(goingForward) {
        const curlPage = this.curlContainer.querySelector('.curl-page');
        const shadow = this.curlContainer.querySelector('.curl-shadow');
        const gradient = this.curlContainer.querySelector('.curl-gradient');

        if (!curlPage) return;

        const startTime = performance.now();
        const duration = this.animationDuration;

        return new Promise(resolve => {
          const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Use easing for smooth motion
            const easedProgress = this.easeInOutCubic(progress);

            // Calculate rotation angles for corner peel effect
            // The page rotates on a diagonal axis (like peeling from top-right corner)
            const maxRotateX = -75;  // Tilt back
            const maxRotateY = goingForward ? -120 : 120;  // Turn sideways
            const maxRotateZ = goingForward ? 25 : -25;  // Slight twist

            const rotateX = easedProgress * maxRotateX;
            const rotateY = easedProgress * maxRotateY;
            const rotateZ = easedProgress * maxRotateZ;

            // Lift the page up and back as it curls
            const liftY = Math.sin(easedProgress * Math.PI) * -80;
            const liftZ = easedProgress * 150;

            // Move page toward the corner it's peeling from
            const moveX = goingForward ? easedProgress * -100 : easedProgress * 100;
            const moveY = easedProgress * -50;

            // Apply the transform
            curlPage.style.transform = `
              translateX(${moveX}px)
              translateY(${moveY + liftY}px)
              translateZ(${liftZ}px)
              rotateX(${rotateX}deg)
              rotateY(${rotateY}deg)
              rotateZ(${rotateZ}deg)
            `;

            // Dynamic shadow
            const shadowIntensity = Math.sin(easedProgress * Math.PI * 0.8);
            shadow.style.opacity = shadowIntensity * 0.6;

            // Gradient overlay intensity
            gradient.style.opacity = shadowIntensity * 0.8;

            // Dynamic box shadow on curling page
            const shadowBlur = 20 + shadowIntensity * 40;
            const shadowOffset = shadowIntensity * 30;
            curlPage.style.boxShadow = `
              ${goingForward ? -shadowOffset : shadowOffset}px ${shadowOffset}px ${shadowBlur}px rgba(0,0,0,${0.3 + shadowIntensity * 0.2})
            `;

            // Slight brightness change
            const brightness = 1 - shadowIntensity * 0.15;
            curlPage.style.filter = `brightness(${brightness})`;

            // Fade out near the end
            if (progress > 0.7) {
              curlPage.style.opacity = 1 - ((progress - 0.7) / 0.3);
            }

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              resolve();
            }
          };

          requestAnimationFrame(animate);
        });
      }

      // Animate page turn to a specific page with paper curl effect
      async turnToPage(targetPage, animate = true) {
        if (targetPage < 1 || targetPage > this.totalPages || targetPage === this.currentPage) return;
        if (this.isAnimating) return;

        const goingForward = targetPage > this.currentPage;
        this.isAnimating = true;

        // Pre-render the target page on the next canvas
        await this.renderPage(targetPage, this.canvasNext);

        if (animate) {
          // Create curl page from current page
          this.createCurlPage(this.canvasCurrent, goingForward);
          this.curlContainer.classList.add('active');

          // Hide the original current page (curl strips will show instead)
          this.pageCurrent.style.opacity = '0';

          // Start revealing next page with animation
          this.pageNext.classList.add(goingForward ? 'turning-in' : 'turning-back-in');

          // Animate the paper curl
          await this.animateCurl(goingForward);

          // Clean up curl animation
          this.curlContainer.classList.remove('active');
          this.curlContainer.innerHTML = '';

          // Remove animation classes
          this.pageNext.classList.remove('turning-in', 'turning-back-in');
          this.pageCurrent.style.opacity = '1';
        }

        // Swap canvases - copy next to current
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.canvasNext.width;
        tempCanvas.height = this.canvasNext.height;
        tempCanvas.getContext('2d').drawImage(this.canvasNext, 0, 0);
        this.canvasCurrent.width = tempCanvas.width;
        this.canvasCurrent.height = tempCanvas.height;
        this.canvasCurrent.getContext('2d').drawImage(tempCanvas, 0, 0);

        // Reset next page
        this.pageNext.classList.remove('current');
        this.pageNext.classList.add('next');
        this.pageCurrent.classList.add('current');
        this.pageCurrent.classList.remove('next');

        this.currentPage = targetPage;
        this.updateIndicator();
        this.isAnimating = false;
      }

      async prevPage() {
        if (this.currentPage > 1) {
          await this.turnToPage(this.currentPage - 1);
        }
      }

      async nextPage() {
        if (this.currentPage < this.totalPages) {
          await this.turnToPage(this.currentPage + 1);
        }
      }

      show() {
        // Recalculate sizes before showing
        this.calculateSizes();

        this.container.style.display = 'flex';
        // Add entering class for animation
        this.container.classList.add('entering');
        // Trigger reflow then add visible class
        this.container.offsetHeight;
        requestAnimationFrame(() => {
          this.container.classList.add('visible');
          // Remove entering class after animation
          setTimeout(() => {
            this.container.classList.remove('entering');
          }, 850);
          // Show zoom hint after booklet appears
          setTimeout(() => {
            if (this.zoomLevel === 0) {
              document.getElementById('zoom-hint').classList.add('visible');
            }
          }, 1200);
        });
      }

      hide() {
        this.container.classList.remove('visible', 'entering');
        document.getElementById('zoom-hint').classList.remove('visible');
        setTimeout(() => {
          if (!this.container.classList.contains('visible')) {
            this.container.style.display = 'none';
          }
        }, 800);
      }

      // Get current page number
      getCurrentPage() {
        return this.currentPage;
      }

      // Get total pages
      getTotalPages() {
        return this.totalPages;
      }
    }

    // ========== ROBOT ASSISTANT ==========
    class RobotGuide {
      constructor() {
        this.element = document.getElementById('robot-assistant');
        this.messageEl = document.getElementById('holo-message');
        this.introMessages = [
          "Hey there! ",
          "I'm Linton's assistant",
          "Nice to meet you!",
          "Click to explore my CV!",
          "Go on, open it! "
        ];
        this.funFactMessages = [
          "Here we go! ",
          "17+ years in tech! ",
          "Based in Auckland ",
          "AWS Certified ",
          "Full stack developer",
          "UC & VoIP specialist ",
          "Interop specialist ",
          "SaaS Development Expert ",
          "Team leadership ",
          "Problem solver ",
          "Thanks for visiting! ",
          "Let's connect! "
        ];
        this.messages = this.introMessages;
        this.currentMessage = 0;
        this.visible = false;
        this.cycleTimer = null;
      }

      show() {
        if (this.visible) return;
        this.visible = true;
        this.element.classList.add('visible');
        this.startMessageCycle();
      }

      hide() {
        this.visible = false;
        this.element.classList.remove('visible');
      }

      setMessage(text) {
        if (this.messageEl) {
          this.messageEl.textContent = text;
        }
      }

      startMessageCycle() {
        this.setMessage(this.messages[0]);
        this.currentMessage = 1;
        this.cycleTimer = setTimeout(() => this.cycleMessages(), 4000);
      }

      cycleMessages() {
        if (!this.visible) return;
        this.setMessage(this.messages[this.currentMessage]);
        this.currentMessage = (this.currentMessage + 1) % this.messages.length;
        this.cycleTimer = setTimeout(() => this.cycleMessages(), 4000);
      }

      switchToFunFacts() {
        // Switch to fun facts after user clicks Open CV
        if (this.cycleTimer) clearTimeout(this.cycleTimer);
        this.messages = this.funFactMessages;
        this.currentMessage = 0;
        this.startMessageCycle();
      }

      showContextMessage(section) {
        // No-op - let fun facts continue cycling
      }

      pauseAndShowMessage(text) {
        // Stop cycling and show a specific message (static, no animation)
        if (this.cycleTimer) clearTimeout(this.cycleTimer);
        this.setMessage(text);
        if (this.messageEl) {
          this.messageEl.classList.add('static');
        }
      }

      stopMessages() {
        // Stop the message cycle and hide the speech bubble, but keep robot visible
        console.log('stopMessages called');
        if (this.cycleTimer) clearTimeout(this.cycleTimer);
        this.messagesHidden = true;
        if (this.messageEl) {
          this.messageEl.style.display = 'none';
        }
        // Enable hover interaction
        console.log('Adding interactive class to element:', this.element);
        this.element.classList.add('interactive');
        this.setupHoverInteraction();
      }

      setupHoverInteraction() {
        if (this.hoverSetup) return;
        this.hoverSetup = true;

        let hideTimeout = null;

        const showHelp = () => {
          if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
          }
          if (this.messagesHidden && this.messageEl.style.display !== 'block') {
            this.showTypingMessage("How can I help? ");
          }
        };

        const hideHelp = () => {
          // Delay hiding to allow mouse to move to message bubble
          hideTimeout = setTimeout(() => {
            if (this.messagesHidden && this.messageEl) {
              this.messageEl.style.display = 'none';
            }
          }, 300);
        };

        // Robot hover events
        this.element.addEventListener('mouseenter', showHelp);
        this.element.addEventListener('mouseleave', hideHelp);

        // Message bubble hover events - keep it open when hovering over options
        this.messageEl.addEventListener('mouseenter', () => {
          if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
          }
        });
        this.messageEl.addEventListener('mouseleave', hideHelp);
      }

      showTypingMessage(text) {
        if (!this.messageEl) return;

        // Cancel any ongoing typing animation
        if (this.typingTimeout) clearTimeout(this.typingTimeout);

        // Show the bubble first (empty)
        this.messageEl.style.display = 'block';
        this.messageEl.classList.add('static');
        this.messageEl.innerHTML = '';

        // Type out the message character by character - faster and smoother
        let i = 0;
        const typeSpeed = 25; // Faster typing

        const typeChar = () => {
          if (i < text.length) {
            // Get current text without the options HTML
            const currentText = this.messageEl.querySelector('.help-text');
            if (currentText) {
              currentText.textContent += text.charAt(i);
            } else {
              this.messageEl.innerHTML = `<span class="help-text">${text.charAt(i)}</span>`;
            }
            i++;
            this.typingTimeout = setTimeout(typeChar, typeSpeed);
          } else {
            // Show help options after typing completes
            this.showHelpOptions();
          }
        };

        // Start typing immediately
        typeChar();
      }

      showHelpOptions() {
        if (!this.messageEl) return;

        const optionsHtml = `
          <div class="help-options">
            <button class="help-option" data-action="skip"> Skip section</button>
            <button class="help-option" data-action="restart"> Restart</button>
            <button class="help-option" data-action="contact"> Contact me</button>
          </div>
        `;

        this.messageEl.innerHTML += optionsHtml;

        // Add click handlers
        this.messageEl.querySelectorAll('.help-option').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = btn.dataset.action;
            if (action === 'skip') {
              // Skip to next section
              if (window.app) window.app.skipToNext();
            } else if (action === 'restart') {
              // Restart from beginning
              if (window.app) {
                window.app.currentSection = 0;
                window.app.isPlaying = true;
                window.app.playSection(0);
              }
            } else if (action === 'contact') {
              window.location.href = 'mailto:linton.evans@outlook.com';
            }
          });
        });
      }
    }

    // Global instances
    const holoGuide = new RobotGuide();

    // Main App
    class App {
      constructor() {
        this.container = document.getElementById('canvas-container');
        this.loadingScreen = document.getElementById('loading-screen');
        this.progressBar = document.getElementById('progress-bar');
        this.startBtn = document.getElementById('start-btn');
        this.infoPanel = document.getElementById('info-panel');
        this.speechBubble = document.getElementById('speech-bubble');
        this.navContainer = document.getElementById('nav-container');
        this.viewCvBtn = document.getElementById('view-cv-btn');
        this.currentSection = 0;
        this.isPlaying = false;
        this.papers = [];
        this.penGroup = null;
        this.inkLine = null;

        this.pdfBooklet = new PDFBooklet();
        this.init();
      }

      async init() {
        this.setupRenderer();
        this.setupScene();
        this.setupCamera();
        this.createLighting();
        this.createBox();
        this.createPapersAndPen();
        this.setupPostProcessing();
        this.setupEvents();
        await this.pdfBooklet.loadPDF('./cv.pdf');
        await this.simulateLoading();
        this.animate();
      }

      setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.setClearColor(0x000000, 0);
        this.container.appendChild(this.renderer.domElement);
      }

      setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = null;
      }

      setupCamera() {
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.5, 4);
        this.camera.lookAt(0, 0.8, 0);
      }

      setupPostProcessing() {
        // Skip post-processing to keep background transparency
        // The neural network background provides enough visual interest
        this.useComposer = false;
      }

      createLighting() {
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const key = new THREE.DirectionalLight(0xffffff, 1);
        key.position.set(3, 5, 5);
        this.scene.add(key);
        const fill = new THREE.DirectionalLight(0x88aaff, 0.4);
        fill.position.set(-3, 3, 2);
        this.scene.add(fill);
        const rim = new THREE.DirectionalLight(0xa3e635, 0.3);
        rim.position.set(0, 2, -4);
        this.scene.add(rim);
      }

      createBox() {
        this.boxGroup = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, metalness: 0.3, roughness: 0.4 });
        const size = 1.5;

        this.boxParts = {};
        this.boxParts.bottom = new THREE.Mesh(new THREE.BoxGeometry(size, 0.06, size), mat);
        this.boxParts.bottom.position.y = -size/2;
        this.boxGroup.add(this.boxParts.bottom);

        const panel = new THREE.BoxGeometry(size, size, 0.06);
        const side = new THREE.BoxGeometry(0.06, size, size);

        this.boxParts.front = new THREE.Mesh(panel, mat);
        this.boxParts.front.position.set(0, 0, size/2);
        this.boxGroup.add(this.boxParts.front);

        this.boxParts.back = new THREE.Mesh(panel, mat);
        this.boxParts.back.position.set(0, 0, -size/2);
        this.boxGroup.add(this.boxParts.back);

        this.boxParts.left = new THREE.Mesh(side, mat);
        this.boxParts.left.position.set(-size/2, 0, 0);
        this.boxGroup.add(this.boxParts.left);

        this.boxParts.right = new THREE.Mesh(side, mat);
        this.boxParts.right.position.set(size/2, 0, 0);
        this.boxGroup.add(this.boxParts.right);

        this.boxParts.lid = new THREE.Mesh(new THREE.BoxGeometry(size+0.08, 0.06, size+0.08), mat);
        this.boxParts.lid.position.y = size/2;
        this.boxGroup.add(this.boxParts.lid);

        this.boxParts.glow = new THREE.PointLight(0xa3e635, 0, 5);
        this.boxGroup.add(this.boxParts.glow);

        this.boxGroup.rotation.y = 0.3;
        this.scene.add(this.boxGroup);
        this.boxUnpacked = false;
      }

      createPapersAndPen() {
        // Helper function to create paper canvas with optional pre-written content
        const createPaperCanvas = (contentType = 'blank') => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 680;
          const ctx = canvas.getContext('2d');

          // Paper background
          ctx.fillStyle = '#faf8f5';
          ctx.fillRect(0, 0, 512, 680);

          // Add subtle paper texture lines
          ctx.strokeStyle = 'rgba(200, 195, 185, 0.3)';
          ctx.lineWidth = 0.5;
          for (let y = 30; y < 680; y += 25) {
            ctx.beginPath();
            ctx.moveTo(30, y);
            ctx.lineTo(482, y);
            ctx.stroke();
          }

          // Add pre-written content based on type
          if (contentType !== 'blank' && contentType !== 'active') {
            ctx.font = 'italic 16px Georgia, serif';
            ctx.fillStyle = 'rgba(25, 25, 50, 0.7)';

            const contentSets = {
              notes1: [
                'Technical Architecture Notes',
                '',
                ' API Design Patterns',
                ' Microservices architecture',
                ' Cloud infrastructure (AWS/Azure)',
                ' Performance optimization',
                '',
                'Key Projects:',
                '- E-commerce platform redesign',
                '- Real-time data processing',
                '- Legacy system migration',
                '',
                'Stakeholder Management',
                ' Cross-functional teams',
                ' Executive presentations'
              ],
              notes2: [
                'Professional Development',
                '',
                'Certifications:',
                ' AWS Solutions Architect',
                ' Microsoft Azure',
                ' ITIL Foundation',
                '',
                'Skills Assessment:',
                '- Leadership: Strong',
                '- Technical: Expert',
                '- Communication: Excellent',
                '',
                'Goals for 2025:',
                ' Expand cloud expertise',
                ' Mentor junior developers'
              ],
              notes3: [
                'Meeting Notes - Q4 Review',
                '',
                'Discussion Points:',
                ' Product roadmap alignment',
                ' Resource allocation',
                ' Timeline adjustments',
                '',
                'Action Items:',
                '1. Review architecture docs',
                '2. Schedule team sync',
                '3. Update stakeholders',
                '',
                'Follow-up required:',
                '- Budget review next week'
              ],
              notes4: [
                'Ideas & Innovation',
                '',
                'New initiatives:',
                ' AI/ML integration',
                ' Process automation',
                ' Developer experience',
                '',
                'Research topics:',
                '- Emerging technologies',
                '- Industry best practices',
                '- Competitive analysis',
                '',
                'Brainstorm session notes',
                'scheduled for Friday'
              ]
            };

            const lines = contentSets[contentType] || contentSets.notes1;
            let y = 60;
            lines.forEach((line, idx) => {
              if (idx === 0) {
                ctx.font = 'bold italic 18px Georgia, serif';
                ctx.fillStyle = 'rgba(25, 25, 50, 0.8)';
              } else {
                ctx.font = 'italic 15px Georgia, serif';
                ctx.fillStyle = 'rgba(25, 25, 50, 0.65)';
              }
              ctx.fillText(line, 45, y);
              y += line === '' ? 15 : 28;
            });

            // Add some decorative squiggles/underlines for realism
            ctx.strokeStyle = 'rgba(25, 25, 50, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(45, 75);
            ctx.lineTo(280, 75);
            ctx.stroke();
          }

          return canvas;
        };

        // Create main paper (center) with canvas texture for active handwriting
        this.inkCanvas = createPaperCanvas('active');
        this.inkCtx = this.inkCanvas.getContext('2d');

        this.paperTexture = new THREE.CanvasTexture(this.inkCanvas);
        this.paperTexture.needsUpdate = true;

        const paperMat = new THREE.MeshStandardMaterial({
          map: this.paperTexture,
          roughness: 0.9,
          side: THREE.DoubleSide,
          metalness: 0
        });

        // Content types for each paper (index 2 is the active one)
        const paperContents = ['notes1', 'notes2', 'active', 'notes3', 'notes4'];

        // Create 5 paper sheets
        for (let i = 0; i < 5; i++) {
          let mat;
          if (i === 2) {
            // Center paper - active writing surface
            mat = paperMat;
          } else {
            // Background papers with pre-written content
            const bgCanvas = createPaperCanvas(paperContents[i]);
            const bgTexture = new THREE.CanvasTexture(bgCanvas);
            mat = new THREE.MeshStandardMaterial({
              map: bgTexture,
              roughness: 0.9,
              side: THREE.DoubleSide,
              metalness: 0
            });
          }

          const paper = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 1.2), mat);
          paper.visible = false;
          paper.userData = {
            targetX: (i - 2) * 0.3,
            targetY: 1.2 + i * 0.02,
            targetZ: 1.5 + i * 0.1,
            targetRotX: -0.3,
            targetRotY: (i - 2) * 0.1,
            delay: i * 0.1
          };
          this.papers.push(paper);
          this.scene.add(paper);
        }

        // Create realistic fountain pen using sprite for cleaner look
        this.penGroup = new THREE.Group();
        this.penGroup.visible = false;

        // Create pen using 2D canvas for crisp rendering
        const penCanvas = document.createElement('canvas');
        penCanvas.width = 64;
        penCanvas.height = 256;
        const pctx = penCanvas.getContext('2d');

        // Draw pen body - elegant black with gold accents
        const gradient = pctx.createLinearGradient(20, 0, 44, 0);
        gradient.addColorStop(0, '#0a0a15');
        gradient.addColorStop(0.3, '#1a1a25');
        gradient.addColorStop(0.7, '#1a1a25');
        gradient.addColorStop(1, '#0a0a15');

        // Barrel
        pctx.fillStyle = gradient;
        pctx.beginPath();
        pctx.roundRect(22, 20, 20, 140, 3);
        pctx.fill();

        // Gold cap band
        pctx.fillStyle = '#c9a227';
        pctx.fillRect(20, 25, 24, 8);
        pctx.fillRect(20, 45, 24, 4);

        // Gold clip
        pctx.fillStyle = '#c9a227';
        pctx.fillRect(44, 30, 4, 50);
        pctx.beginPath();
        pctx.arc(46, 80, 4, 0, Math.PI * 2);
        pctx.fill();

        // Grip section (darker)
        pctx.fillStyle = '#15152a';
        pctx.beginPath();
        pctx.moveTo(26, 160);
        pctx.lineTo(38, 160);
        pctx.lineTo(36, 195);
        pctx.lineTo(28, 195);
        pctx.closePath();
        pctx.fill();

        // Gold nib
        pctx.fillStyle = '#d4af37';
        pctx.beginPath();
        pctx.moveTo(32, 195);
        pctx.lineTo(26, 230);
        pctx.quadraticCurveTo(32, 256, 32, 256);
        pctx.quadraticCurveTo(32, 256, 38, 230);
        pctx.lineTo(32, 195);
        pctx.fill();

        // Nib slit
        pctx.strokeStyle = '#000';
        pctx.lineWidth = 1;
        pctx.beginPath();
        pctx.moveTo(32, 210);
        pctx.lineTo(32, 252);
        pctx.stroke();

        // Breather hole
        pctx.fillStyle = '#000';
        pctx.beginPath();
        pctx.arc(32, 215, 2, 0, Math.PI * 2);
        pctx.fill();

        const penTexture = new THREE.CanvasTexture(penCanvas);
        const penMaterial = new THREE.SpriteMaterial({
          map: penTexture,
          transparent: true
        });
        this.penSprite = new THREE.Sprite(penMaterial);
        this.penSprite.scale.set(0.15, 0.6, 1);
        this.penGroup.add(this.penSprite);

        this.scene.add(this.penGroup);

        // Initialize ink drawing state
        this.inkPoints = [];
        this.lastInkPoint = null;
      }

      setupEvents() {
        this.startBtn.addEventListener('click', () => {
          this.startExperience();
        });
        document.getElementById('skip-btn').addEventListener('click', () => {
          this.skipToNext();
        });
        document.querySelectorAll('.nav-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            this.goToSection(parseInt(e.target.dataset.section));
          });
        });
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('keydown', e => {
          if (e.key === 'ArrowRight' || e.key === ' ') this.skipToNext();
          if (e.key === 'ArrowLeft') this.goToSection(Math.max(0, this.currentSection - 1));
        });

        // Download CV button
        document.getElementById('download-cv-btn').addEventListener('click', () => {
          // Try to download the CV PDF
          const link = document.createElement('a');
          link.href = './cv.pdf';
          link.download = 'Linton_Evans_CV.pdf';
          link.click();
        });
      }

      async simulateLoading() {
        // Slower, more gradual loading with variable speeds
        const steps = [0, 15, 35, 50, 70, 85, 95, 100];
        const delays = [400, 350, 300, 400, 350, 300, 250]; // Variable delays between steps

        for (let i = 0; i < steps.length; i++) {
          this.progressBar.style.width = `${steps[i]}%`;
          if (i < delays.length) {
            await new Promise(r => setTimeout(r, delays[i]));
          }
        }
        await new Promise(r => setTimeout(r, 500));
        this.loadingScreen.classList.add('hidden');
        this.startBtn.classList.add('visible');

        // Show robot guide on home page to greet user
        setTimeout(() => holoGuide.show(), 1000);
      }

      async startExperience() {
        console.log('startExperience called');
        this.startBtn.style.display = 'none';
        this.isPlaying = true;

        // Show "Here we go!" message during box unpack (stops cycling first)
        holoGuide.pauseAndShowMessage("Here we go! ");

        await this.unpackBoxWithPapers();
        console.log('Box unpacked, showing nav and starting playSection');

        // Now stop robot's messages so main speech bubbles can take over
        holoGuide.stopMessages();

        this.navContainer.style.display = 'flex';
        this.viewCvBtn.classList.add('visible');
        this.playSection(0);
      }

      async unpackBoxWithPapers() {
        return new Promise(resolve => {
          const duration = 6000;
          const start = performance.now();
          let papersFlying = false;
          let penWriting = false;
          let penWriteStart = 0;

          // Create realistic handwriting path on canvas
          // "Linton Evans" signature with proper letter forms
          const signaturePath = this.generateSignaturePath();
          let currentPathIndex = 0;

          const animate = (now) => {
            const elapsed = now - start;
            const t = Math.min(elapsed / duration, 1);

            // Phase 1: Open lid and fly off (0 - 0.25)
            if (t < 0.25) {
              const lt = t / 0.25;
              this.boxParts.glow.intensity = Math.sin(Math.min(lt * 2, 1) * Math.PI) * 3;

              if (lt < 0.4) {
                // First part: lid opens
                const openT = lt / 0.4;
                this.boxParts.lid.position.y = 0.75 + openT * 1.2;
                this.boxParts.lid.rotation.x = -openT * Math.PI / 2.5;
              } else {
                // Second part: lid flies off screen
                const flyT = (lt - 0.4) / 0.6;
                const flyEase = flyT * flyT; // accelerate
                this.boxParts.lid.position.y = 1.95 + flyEase * 5;
                this.boxParts.lid.position.z = flyEase * -3;
                this.boxParts.lid.rotation.x = -Math.PI / 2.5 - flyEase * Math.PI;
                this.boxParts.lid.material.opacity = 1 - flyT;
                this.boxParts.lid.material.transparent = true;
              }
            } else {
              // Hide lid completely after animation
              this.boxParts.lid.visible = false;
            }

            // Phase 2: Papers fly out (0.12 - 0.4)
            if (t > 0.12 && !papersFlying) {
              papersFlying = true;
              this.papers.forEach(p => {
                p.visible = true;
                p.position.set(0, 0, 0);
                p.rotation.set(0, 0, 0);
                p.scale.set(0.1, 0.1, 0.1);
              });
            }

            if (papersFlying && t < 0.4) {
              const pt = (t - 0.12) / 0.28;
              this.papers.forEach((paper, i) => {
                const d = paper.userData;
                const localT = Math.max(0, Math.min(1, (pt - d.delay) / (1 - d.delay)));
                const ease = 1 - Math.pow(1 - localT, 3);

                paper.position.x = d.targetX * ease;
                paper.position.y = d.targetY * ease + Math.sin(localT * Math.PI) * 0.5;
                paper.position.z = d.targetZ * ease;
                paper.rotation.x = d.targetRotX * ease + (1 - ease) * Math.PI * 2;
                paper.rotation.y = d.targetRotY * ease;
                paper.rotation.z = (1 - ease) * Math.PI;
                paper.scale.setScalar(0.1 + ease * 0.9);
              });
            }

            // Phase 3: Box sides fall (0.15 - 0.35)
            if (t > 0.15 && t < 0.35) {
              const st = (t - 0.15) / 0.2;
              this.boxParts.front.position.y = -st * 2;
              this.boxParts.front.rotation.x = -st * Math.PI / 2;
              this.boxParts.back.position.y = -st * 2;
              this.boxParts.back.rotation.x = st * Math.PI / 2;
              this.boxParts.left.position.y = -st * 2;
              this.boxParts.left.rotation.z = st * Math.PI / 2;
              this.boxParts.right.position.y = -st * 2;
              this.boxParts.right.rotation.z = -st * Math.PI / 2;
            }

            // Phase 4: Pen appears, approaches paper, then writes (0.28 - 0.78)
            // First sub-phase: Pen appears and approaches (0.28 - 0.38)
            // Second sub-phase: Pen writes (0.38 - 0.78)
            const penAppearTime = 0.28;
            const penReachPaperTime = 0.38;
            const penEndTime = 0.78;

            if (t > penAppearTime && !penWriting) {
              penWriting = true;
              penWriteStart = now;
              this.penGroup.visible = true;
              // Start pen off to the upper right, ready to swoop in
              this.penGroup.position.set(0.8, 2.5, 2.5);
            }

            if (penWriting && t < penEndTime) {
              // Pen base Z - in front of all papers
              const penBaseZ = 2.1;

              // Pen nib offset - the nib is at the bottom of the sprite
              // Sprite scale is 0.15 x 0.6, so half height is 0.3
              // Move pen UP so the nib tip aligns with ink point
              const nibOffsetY = 0.15;

              // Helper to convert canvas coords to 3D pen position
              const canvasTo3D = (canvasX, canvasY) => {
                // Paper geometry is 0.9 x 1.2, centered at paper position
                // Canvas is 512 x 680
                // Center paper (index 2) is at y=1.24 (1.2 + 2*0.02)
                const paperCenterY = 1.24;
                const paperWidth = 0.9;
                const paperHeight = 1.2;

                // Canvas Y: 0 = top, 680 = bottom
                // 3D Y: higher = up on screen
                // So canvasY=80 (near top) should give high 3D Y
                const penX = (canvasX / 512 - 0.5) * paperWidth;
                const penY = paperCenterY + (0.5 - canvasY / 680) * paperHeight + nibOffsetY;
                return { x: penX, y: penY };
              };

              // Get first point of signature for pen target
              const firstPoint = signaturePath[0];
              const firstPen3D = canvasTo3D(firstPoint.x, firstPoint.y);

              let targetPenX, targetPenY, targetPenZ;
              let penRotation = -0.5;

              if (t < penReachPaperTime) {
                // APPROACH PHASE: Pen swoops down to starting position (no ink yet)
                const approachT = (t - penAppearTime) / (penReachPaperTime - penAppearTime);
                const approachEase = 1 - Math.pow(1 - approachT, 3); // ease out cubic

                // Interpolate from start position to first writing point
                targetPenX = 0.8 + (firstPen3D.x - 0.8) * approachEase;
                targetPenY = 2.5 + (firstPen3D.y - 2.5) * approachEase;
                targetPenZ = 2.5 + (penBaseZ - 2.5) * approachEase;

                // Pen tilts as it approaches
                penRotation = -0.3 + approachEase * -0.2;

              } else {
                // WRITING PHASE: Pen moves along signature path and draws ink
                const writeStartTime = penReachPaperTime;
                const writeDuration = penEndTime - penReachPaperTime;
                const penT = Math.min((t - writeStartTime) / writeDuration, 1);

                // Smooth easing for pen progress
                const easedPenT = penT < 0.5
                  ? 2 * penT * penT
                  : 1 - Math.pow(-2 * penT + 2, 2) / 2;

                // Calculate which point the pen should be at
                const exactIndex = easedPenT * signaturePath.length;
                const idx1 = Math.floor(exactIndex);
                const idx2 = Math.min(idx1 + 1, signaturePath.length - 1);
                const blend = exactIndex - idx1;

                if (idx1 < signaturePath.length && penT < 0.92) {
                  const point1 = signaturePath[idx1];
                  const point2 = signaturePath[idx2];

                  // Interpolate between points for smooth pen movement
                  const interpX = point1.x + (point2.x - point1.x) * blend;
                  const interpY = point1.y + (point2.y - point1.y) * blend;

                  // Position pen FIRST at the exact point
                  const pen3D = canvasTo3D(interpX, interpY);
                  targetPenX = pen3D.x;
                  targetPenY = pen3D.y;
                  targetPenZ = penBaseZ;

                  // Check if current point is a lift (pen up)
                  if (point1.lift) {
                    targetPenY += 0.08;
                    targetPenZ += 0.03;
                  }

                  // Natural pen tilt based on writing direction
                  if (idx2 > idx1 && !point1.lift) {
                    const dx = point2.x - point1.x;
                    const dy = point2.y - point1.y;
                    penRotation = -0.5 + Math.atan2(dy, dx) * 0.1;
                  }

                  // NOW draw ink up to current position (ink follows pen, not the other way around)
                  while (currentPathIndex <= idx1 && currentPathIndex < signaturePath.length) {
                    const point = signaturePath[currentPathIndex];
                    this.drawInkPoint(point);
                    currentPathIndex++;
                  }
                  this.paperTexture.needsUpdate = true;

                } else {
                  // Pen lifts away gracefully at the end
                  const liftT = Math.min((penT - 0.92) / 0.08, 1);
                  const liftEase = liftT * liftT;

                  // Draw any remaining ink
                  while (currentPathIndex < signaturePath.length) {
                    const point = signaturePath[currentPathIndex];
                    this.drawInkPoint(point);
                    currentPathIndex++;
                  }
                  this.paperTexture.needsUpdate = true;

                  // Get last signature point as starting position for lift
                  const lastPoint = signaturePath[signaturePath.length - 1];
                  const lastPen3D = canvasTo3D(lastPoint.x, lastPoint.y);

                  targetPenX = lastPen3D.x + liftEase * 1.0;
                  targetPenY = lastPen3D.y + liftEase * 0.8;
                  targetPenZ = penBaseZ + liftEase * 0.6;
                  penRotation = -0.5 + liftEase * 0.4;
                }
              }

              // Direct pen positioning during writing (no lag)
              // Only use lerp for approach phase smoothness
              if (t < penReachPaperTime) {
                const lerpSpeed = 0.3;
                this.penGroup.position.x += (targetPenX - this.penGroup.position.x) * lerpSpeed;
                this.penGroup.position.y += (targetPenY - this.penGroup.position.y) * lerpSpeed;
                this.penGroup.position.z += (targetPenZ - this.penGroup.position.z) * lerpSpeed;
              } else {
                // During writing: pen follows ink exactly
                this.penGroup.position.x = targetPenX;
                this.penGroup.position.y = targetPenY;
                this.penGroup.position.z = targetPenZ;
              }

              // Smooth rotation always
              const currentRotation = this.penSprite.material.rotation;
              this.penSprite.material.rotation += (penRotation - currentRotation) * 0.15;
            }

            // Phase 5: Pen fades and papers stack together (0.78 - 0.88)
            if (t > 0.78 && t <= 0.88) {
              const stackT = (t - 0.78) / 0.10;
              const stackEase = 1 - Math.pow(1 - stackT, 3); // ease out cubic

              // Fade out pen
              if (this.penSprite && this.penSprite.material) {
                this.penSprite.material.opacity = 1 - stackT;
              }

              // Animate all papers to stack together at center
              this.papers.forEach((paper, i) => {
                const d = paper.userData;
                // Target: all papers stack at center, slightly offset in Z for depth
                const stackX = 0;
                const stackY = 1.35;
                const stackZ = 1.7 + i * 0.008; // Tiny offset for stacking effect
                const stackRotX = -0.25;
                const stackRotY = 0;

                // Interpolate from spread position to stack position
                paper.position.x = d.targetX * (1 - stackEase) + stackX * stackEase;
                paper.position.y = d.targetY * (1 - stackEase) + stackY * stackEase;
                paper.position.z = d.targetZ * (1 - stackEase) + stackZ * stackEase;
                paper.rotation.x = d.targetRotX * (1 - stackEase) + stackRotX * stackEase;
                paper.rotation.y = d.targetRotY * (1 - stackEase) + stackRotY * stackEase;
                paper.rotation.z = 0;
              });
            }

            // Phase 6: Stacked papers sink into background (0.88 - 1.0)
            if (t > 0.88) {
              const sinkT = (t - 0.88) / 0.12;
              const sinkEase = sinkT < 0.5
                ? 2 * sinkT * sinkT
                : 1 - Math.pow(-2 * sinkT + 2, 2) / 2; // ease in-out quad

              // Ensure pen is hidden
              if (this.penSprite && this.penSprite.material) {
                this.penSprite.material.opacity = 0;
              }

              // Animate stacked papers to sink into background
              this.papers.forEach((paper, i) => {
                // Start from stacked position
                const stackX = 0;
                const stackY = 1.35;
                const stackZ = 1.7 + i * 0.008;
                const stackRotX = -0.25;

                // Target: sink back, down, and scale smaller
                const sinkX = 0;
                const sinkY = 0.3;
                const sinkZ = -2;
                const sinkRotX2 = -0.1;
                const sinkScale = 0.3;

                // Interpolate from stack position to sink position
                paper.position.x = stackX * (1 - sinkEase) + sinkX * sinkEase;
                paper.position.y = stackY * (1 - sinkEase) + sinkY * sinkEase;
                paper.position.z = stackZ * (1 - sinkEase) + sinkZ * sinkEase;
                paper.rotation.x = stackRotX * (1 - sinkEase) + sinkRotX2 * sinkEase;

                // Scale down as they sink
                const currentScale = 1 - (1 - sinkScale) * sinkEase;
                paper.scale.set(currentScale, currentScale, 1);

                // Fade out towards the end
                if (sinkT > 0.5) {
                  const fadeT = (sinkT - 0.5) / 0.5;
                  paper.material.transparent = true;
                  paper.material.opacity = 1 - fadeT;
                }
              });
            }

            if (t < 1) {
              requestAnimationFrame(animate);
            } else {
              this.boxGroup.visible = false;
              this.papers.forEach(p => p.visible = false);
              this.penGroup.visible = false;
              this.boxUnpacked = true;

              setTimeout(() => this.pdfBooklet.show(), 300);
              resolve();
            }
          };

          requestAnimationFrame(animate);
        });
      }

      // Generate multiple lines of handwritten text
      generateSignaturePath() {
        const path = [];

        // Helper to add bezier curve points
        const addCurve = (x1, y1, cx1, cy1, cx2, cy2, x2, y2, pressure = 1) => {
          for (let t = 0; t <= 1; t += 0.03) {
            const mt = 1 - t;
            const x = mt*mt*mt*x1 + 3*mt*mt*t*cx1 + 3*mt*t*t*cx2 + t*t*t*x2;
            const y = mt*mt*mt*y1 + 3*mt*mt*t*cy1 + 3*mt*t*t*cy2 + t*t*t*y2;
            path.push({ x, y, pressure: pressure * (0.8 + Math.sin(t * Math.PI) * 0.2), lift: false });
          }
        };

        // Helper to write cursive text at position
        const writeWord = (word, startX, startY, scale = 1) => {
          let x = startX;
          const letterSpacing = 12 * scale;

          for (const char of word.toLowerCase()) {
            const s = scale;
            switch(char) {
              case 'l':
                addCurve(x, startY, x, startY - 35*s, x + 3*s, startY - 45*s, x + 6*s, startY - 38*s, 1);
                addCurve(x + 6*s, startY - 38*s, x + 10*s, startY - 30*s, x + 6*s, startY, x + 20*s, startY + 5*s, 0.9);
                x += 18 * s;
                break;
              case 'i':
                path.push({ x: x + 2*s, y: startY, pressure: 0, lift: true });
                addCurve(x + 2*s, startY, x + 4*s, startY - 15*s, x + 8*s, startY - 18*s, x + 10*s, startY + 3*s, 0.8);
                x += 12 * s;
                break;
              case 'n':
                addCurve(x, startY + 3*s, x + 3*s, startY - 18*s, x + 12*s, startY - 18*s, x + 14*s, startY + 3*s, 0.85);
                addCurve(x + 14*s, startY + 3*s, x + 17*s, startY - 18*s, x + 26*s, startY - 18*s, x + 28*s, startY + 3*s, 0.85);
                x += 30 * s;
                break;
              case 't':
                addCurve(x, startY + 3*s, x + 3*s, startY - 25*s, x + 7*s, startY - 30*s, x + 10*s, startY + 3*s, 0.8);
                path.push({ x: x + 2*s, y: startY - 15*s, pressure: 0, lift: true });
                path.push({ x: x + 2*s, y: startY - 15*s, pressure: 0.6, lift: false });
                path.push({ x: x + 14*s, y: startY - 15*s, pressure: 0.6, lift: false });
                x += 14 * s;
                break;
              case 'o':
                path.push({ x: x + 2*s, y: startY, pressure: 0, lift: true });
                addCurve(x + 2*s, startY, x, startY - 15*s, x + 12*s, startY - 18*s, x + 15*s, startY, 0.75);
                addCurve(x + 15*s, startY, x + 18*s, startY + 8*s, x + 5*s, startY + 8*s, x + 2*s, startY, 0.75);
                x += 18 * s;
                break;
              case 'e':
                path.push({ x: x + 2*s, y: startY - 8*s, pressure: 0, lift: true });
                addCurve(x + 2*s, startY - 8*s, x + 15*s, startY - 10*s, x + 15*s, startY - 18*s, x + 8*s, startY - 18*s, 0.8);
                addCurve(x + 8*s, startY - 18*s, x, startY - 16*s, x, startY + 5*s, x + 12*s, startY + 8*s, 0.8);
                x += 16 * s;
                break;
              case 'v':
                path.push({ x: x + 2*s, y: startY - 3*s, pressure: 0, lift: true });
                addCurve(x + 2*s, startY - 3*s, x + 5*s, startY - 18*s, x + 10*s, startY + 10*s, x + 14*s, startY + 3*s, 0.8);
                addCurve(x + 14*s, startY + 3*s, x + 18*s, startY - 8*s, x + 25*s, startY - 18*s, x + 28*s, startY, 0.8);
                x += 28 * s;
                break;
              case 'a':
                addCurve(x, startY, x - 3*s, startY - 15*s, x + 10*s, startY - 18*s, x + 14*s, startY, 0.75);
                addCurve(x + 14*s, startY, x + 17*s, startY + 7*s, x + 3*s, startY + 7*s, x, startY, 0.75);
                addCurve(x + 14*s, startY, x + 16*s, startY - 8*s, x + 20*s, startY - 3*s, x + 22*s, startY + 3*s, 0.75);
                x += 24 * s;
                break;
              case 's':
                addCurve(x, startY + 3*s, x + 3*s, startY - 10*s, x + 12*s, startY - 15*s, x + 15*s, startY - 8*s, 0.8);
                addCurve(x + 15*s, startY - 8*s, x + 18*s, startY, x + 8*s, startY + 10*s, x + 18*s, startY + 12*s, 0.85);
                x += 20 * s;
                break;
              case 'c':
                path.push({ x: x + 12*s, y: startY - 12*s, pressure: 0, lift: true });
                addCurve(x + 12*s, startY - 12*s, x + 5*s, startY - 18*s, x, startY - 5*s, x + 5*s, startY + 5*s, 0.8);
                addCurve(x + 5*s, startY + 5*s, x + 10*s, startY + 10*s, x + 15*s, startY + 3*s, x + 18*s, startY, 0.8);
                x += 18 * s;
                break;
              case 'u':
                path.push({ x: x, y: startY - 3*s, pressure: 0, lift: true });
                addCurve(x, startY - 3*s, x + 2*s, startY + 10*s, x + 12*s, startY + 10*s, x + 14*s, startY - 3*s, 0.8);
                addCurve(x + 14*s, startY - 3*s, x + 16*s, startY + 10*s, x + 20*s, startY + 5*s, x + 22*s, startY + 3*s, 0.8);
                x += 24 * s;
                break;
              case 'r':
                addCurve(x, startY + 3*s, x + 2*s, startY - 15*s, x + 8*s, startY - 18*s, x + 12*s, startY - 10*s, 0.8);
                x += 14 * s;
                break;
              case 'm':
                addCurve(x, startY + 3*s, x + 3*s, startY - 18*s, x + 12*s, startY - 18*s, x + 14*s, startY + 3*s, 0.85);
                addCurve(x + 14*s, startY + 3*s, x + 17*s, startY - 18*s, x + 26*s, startY - 18*s, x + 28*s, startY + 3*s, 0.85);
                addCurve(x + 28*s, startY + 3*s, x + 31*s, startY - 18*s, x + 40*s, startY - 18*s, x + 42*s, startY + 3*s, 0.85);
                x += 44 * s;
                break;
              case 'p':
                addCurve(x, startY - 3*s, x + 2*s, startY + 25*s, x + 4*s, startY + 30*s, x + 6*s, startY + 25*s, 0.8);
                path.push({ x: x + 4*s, y: startY - 3*s, pressure: 0, lift: true });
                addCurve(x + 4*s, startY - 3*s, x + 3*s, startY - 15*s, x + 15*s, startY - 18*s, x + 18*s, startY - 5*s, 0.8);
                addCurve(x + 18*s, startY - 5*s, x + 20*s, startY + 5*s, x + 8*s, startY + 5*s, x + 4*s, startY - 3*s, 0.8);
                x += 22 * s;
                break;
              case 'd':
                addCurve(x, startY, x - 3*s, startY - 15*s, x + 8*s, startY - 18*s, x + 12*s, startY, 0.75);
                addCurve(x + 12*s, startY, x + 15*s, startY + 7*s, x + 3*s, startY + 7*s, x, startY, 0.75);
                path.push({ x: x + 12*s, y: startY, pressure: 0, lift: true });
                addCurve(x + 12*s, startY, x + 14*s, startY - 35*s, x + 16*s, startY - 40*s, x + 18*s, startY + 5*s, 0.8);
                x += 22 * s;
                break;
              case 'y':
                path.push({ x: x, y: startY - 3*s, pressure: 0, lift: true });
                addCurve(x, startY - 3*s, x + 5*s, startY - 15*s, x + 10*s, startY + 8*s, x + 14*s, startY + 3*s, 0.8);
                addCurve(x + 14*s, startY + 3*s, x + 18*s, startY - 10*s, x + 8*s, startY + 25*s, x + 5*s, startY + 30*s, 0.8);
                x += 18 * s;
                break;
              case 'h':
                addCurve(x, startY + 5*s, x + 2*s, startY - 35*s, x + 5*s, startY - 40*s, x + 8*s, startY - 35*s, 1);
                addCurve(x + 8*s, startY - 35*s, x + 10*s, startY - 25*s, x + 6*s, startY, x + 8*s, startY + 3*s, 0.9);
                addCurve(x + 8*s, startY + 3*s, x + 12*s, startY - 15*s, x + 20*s, startY - 15*s, x + 22*s, startY + 5*s, 0.85);
                x += 24 * s;
                break;
              case 'w':
                path.push({ x: x, y: startY - 3*s, pressure: 0, lift: true });
                addCurve(x, startY - 3*s, x + 5*s, startY + 10*s, x + 10*s, startY - 15*s, x + 15*s, startY + 5*s, 0.8);
                addCurve(x + 15*s, startY + 5*s, x + 20*s, startY - 15*s, x + 25*s, startY + 10*s, x + 30*s, startY - 3*s, 0.8);
                x += 32 * s;
                break;
              case 'k':
                addCurve(x, startY + 5*s, x + 2*s, startY - 35*s, x + 5*s, startY - 40*s, x + 8*s, startY - 35*s, 1);
                addCurve(x + 8*s, startY - 35*s, x + 10*s, startY - 25*s, x + 6*s, startY + 5*s, x + 8*s, startY + 5*s, 0.9);
                path.push({ x: x + 18*s, y: startY - 15*s, pressure: 0, lift: true });
                addCurve(x + 18*s, startY - 15*s, x + 12*s, startY - 8*s, x + 6*s, startY - 3*s, x + 8*s, startY - 3*s, 0.75);
                addCurve(x + 8*s, startY - 3*s, x + 12*s, startY + 3*s, x + 18*s, startY + 8*s, x + 22*s, startY + 5*s, 0.8);
                x += 24 * s;
                break;
              case 'x':
                path.push({ x: x, y: startY - 12*s, pressure: 0, lift: true });
                addCurve(x, startY - 12*s, x + 8*s, startY, x + 12*s, startY + 8*s, x + 18*s, startY + 5*s, 0.8);
                path.push({ x: x + 18*s, y: startY - 12*s, pressure: 0, lift: true });
                addCurve(x + 18*s, startY - 12*s, x + 10*s, startY, x + 5*s, startY + 8*s, x, startY + 5*s, 0.8);
                x += 20 * s;
                break;
              case ' ':
                path.push({ x: x + 10*s, y: startY, pressure: 0, lift: true });
                x += 15 * s;
                break;
              default:
                x += 10 * s;
            }
          }
          return x;
        };

        // Line 1: "Linton Evans" - signature style (larger)
        let lineY = 80;
        writeWord('Linton Evans', 50, lineY, 1.1);

        // Line 2: Title
        lineY += 55;
        path.push({ x: 50, y: lineY, pressure: 0, lift: true });
        writeWord('Product Architect', 50, lineY, 0.85);

        // Line 3: Company
        lineY += 45;
        path.push({ x: 50, y: lineY, pressure: 0, lift: true });
        writeWord('Seventeen years', 50, lineY, 0.8);

        // Line 4: experience
        lineY += 45;
        path.push({ x: 50, y: lineY, pressure: 0, lift: true });
        writeWord('in tech', 50, lineY, 0.8);

        // Signature flourish at end
        lineY += 60;
        path.push({ x: 50, y: lineY, pressure: 0, lift: true });
        addCurve(50, lineY, 150, lineY - 10, 280, lineY + 5, 400, lineY - 5, 0.5);

        return path;
      }

      // Draw a single ink point on the canvas
      drawInkPoint(point) {
        if (point.lift) {
          this.lastInkPoint = null;
          return;
        }

        const ctx = this.inkCtx;

        if (this.lastInkPoint && !this.lastInkPoint.lift) {
          // Draw line from last point with varying thickness
          ctx.beginPath();
          ctx.strokeStyle = `rgba(15, 15, 40, ${0.85 + Math.random() * 0.1})`;
          ctx.lineWidth = 1.5 + point.pressure * 1.5;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.moveTo(this.lastInkPoint.x, this.lastInkPoint.y);
          ctx.lineTo(point.x, point.y);
          ctx.stroke();

          // Add slight ink spread for realism
          if (Math.random() > 0.7) {
            ctx.beginPath();
            ctx.fillStyle = 'rgba(15, 15, 40, 0.1)';
            ctx.arc(point.x, point.y, point.pressure * 2 + Math.random(), 0, Math.PI * 2);
            ctx.fill();
          }
        }

        this.lastInkPoint = point;
      }

      async playSection(index) {
        console.log('playSection called with index:', index, 'isPlaying:', this.isPlaying);
        this.currentSection = index;
        this.updateNavigation();
        const sections = ['welcome', 'about', 'experience', 'skills', 'education', 'contact'];
        const sectionName = sections[index];
        console.log('Section name:', sectionName);

        // Update holographic guide with context
        holoGuide.showContextMessage(sectionName);

        // Map sections to PDF pages
        const sectionToPage = {
          welcome: 1,
          about: 1,
          experience: 2,
          skills: 2,
          education: 3,
          contact: 4
        };

        // Trigger page turn animation to the appropriate page
        const targetPage = sectionToPage[sectionName];
        const totalPages = this.pdfBooklet.getTotalPages();
        if (targetPage && targetPage <= totalPages) {
          await this.pdfBooklet.turnToPage(targetPage);
        }

        // Dynamic bubble positions - alternates between left and right with random offsets
        const getRandomPosition = (lastSide) => {
          // Alternate sides, with random position on that side
          const newSide = lastSide === 'left' ? 'right' : 'left';
          return { side: newSide, position: `pos-dynamic-${newSide}` };
        };

        const icons = {
          welcome: '',
          about: '',
          experience: '',
          skills: '',
          education: '',
          contact: ''
        };

        // Get speeches for this section (now an array)
        const speeches = cvData.speeches[sectionName];
        let lastSide = Math.random() > 0.5 ? 'left' : 'right'; // Random starting side

        // Add initial delay for first section to let user see the CV first
        if (index === 0) {
          await new Promise(r => setTimeout(r, 2500)); // 2.5 second delay before first bubble
        }

        // Cycle through all speeches for this section
        for (let i = 0; i < speeches.length; i++) {
          // Check if we're still on this section
          if (!this.isPlaying || this.currentSection !== index) break;

          const speech = speeches[i];
          let position;

          if (sectionName === 'contact') {
            position = 'pos-center';
          } else {
            const posData = getRandomPosition(lastSide);
            lastSide = posData.side;
            position = posData.position;
          }

          this.hideSpeechBubble();
          await new Promise(r => setTimeout(r, 250));

          console.log('Showing speech bubble:', speech, position);
          this.showSpeechBubble(speech, position, icons[sectionName]);

          // Wait for user to read (based on text length)
          const readTime = Math.max(3500, speech.length * 40);
          console.log('Waiting for', readTime, 'ms');
          await new Promise(r => setTimeout(r, readTime));
        }

        // If this is the contact (final) section, close the booklet after showing bubbles
        if (sectionName === 'contact' && this.isPlaying) {
          await new Promise(r => setTimeout(r, 1000));
          this.hideSpeechBubble();
          await new Promise(r => setTimeout(r, 500));
          this.pdfBooklet.hide();

          // Show "Let's Go!" popup
          await new Promise(r => setTimeout(r, 300));
          const letsGoPopup = document.getElementById('lets-go-popup');
          letsGoPopup.classList.add('visible');
          holoGuide.setMessage("Thanks for watching!");

          // Remove the class after animation completes, then show Connect Now button
          setTimeout(() => {
            letsGoPopup.classList.remove('visible');

            // Show Connect Now button after Let's Go fades
            setTimeout(() => {
              const connectBtn = document.getElementById('connect-now-btn');
              connectBtn.classList.add('visible');

              // Show persistent contact bubble
              setTimeout(() => {
                const contactPersistent = document.getElementById('contact-persistent');
                contactPersistent.classList.add('visible');

                // Show action buttons (LinkedIn share, Download CV)
                setTimeout(() => {
                  document.getElementById('action-buttons').classList.add('visible');
                }, 500);
              }, 800);
            }, 300);
          }, 2500);
        }

        // Move to next section
        if (index < sections.length - 1 && this.isPlaying) {
          if (this.isPlaying && this.currentSection === index) {
            this.hideSpeechBubble();
            this.hideInfoPanel();
            await new Promise(r => setTimeout(r, 500));
            this.playSection(index + 1);
          }
        }
      }

      updateInfoPanel(sectionName, position) {
        // If position is null, hide the panel
        if (!position) {
          this.hideInfoPanel();
          return;
        }

        const data = {
          welcome: { title: cvData.personal.name, subtitle: cvData.personal.title, content: `${cvData.personal.location}\n${cvData.personal.email}` },
          about: { title: 'About Me', subtitle: '17+ Years Experience', content: cvData.shortSummary },
          experience: { title: 'Experience', subtitle: '4 Key Roles', content: cvData.experience.map(e => `${e.title}\n${e.company}`).join('\n\n') },
          skills: { title: 'Technical Skills', subtitle: 'Full Stack', content: Object.values(cvData.skills).flat().join('  ') },
          education: { title: 'Education', subtitle: cvData.education[0].degree, content: cvData.education[0].institution },
          contact: { title: "Let's Connect", subtitle: cvData.personal.noticePeriod, content: `${cvData.personal.email}\n${cvData.personal.phone}` }
        }[sectionName];

        // Remove old position classes and add new one
        this.infoPanel.className = 'info-panel ' + position;
        document.getElementById('panel-title').textContent = data.title;
        document.getElementById('panel-subtitle').textContent = data.subtitle;
        document.getElementById('panel-content').textContent = data.content;

        // Small delay for position change to take effect before showing
        requestAnimationFrame(() => {
          this.infoPanel.classList.add('visible');
        });
      }

      hideInfoPanel() {
        this.infoPanel.classList.remove('visible');
      }

      showSpeechBubble(text, position, icon = '') {
        const iconSpan = icon ? `<span class="section-icon">${icon}</span>` : '';
        document.getElementById('speech-text').innerHTML = iconSpan + text;

        // Random animation types
        const animations = ['anim-fade', 'anim-slide-left', 'anim-slide-right', 'anim-slide-up', 'anim-slide-down', 'anim-pop', 'anim-swing'];
        const randomAnim = animations[Math.floor(Math.random() * animations.length)];

        // Check if mobile - skip dynamic positioning (CSS handles it)
        const isMobile = window.innerWidth <= 480;

        // Check if using dynamic positioning (random offsets) - only on desktop
        if ((position === 'pos-dynamic-left' || position === 'pos-dynamic-right') && !isMobile) {
          // Clear fixed position classes, add random animation
          this.speechBubble.className = 'speech-bubble pos-dynamic ' + randomAnim;

          // Reset inline styles
          this.speechBubble.style.top = '';
          this.speechBubble.style.bottom = '';
          this.speechBubble.style.left = '';
          this.speechBubble.style.right = '';

          // Calculate the CV page boundaries
          // CV is centered, base width 450px * scale factor
          const zoomLevel = this.pdfBooklet ? this.pdfBooklet.zoomLevel : 0;
          const scales = [1.25, 1.5, 1.9, 2.5]; // default, zoomed, zoomed-max, zoomed-ultra
          const scale = scales[zoomLevel] || 1.25;
          const cvWidth = 450 * scale;
          const screenWidth = window.innerWidth;

          // Calculate left and right margins (dark space)
          const cvLeft = (screenWidth - cvWidth) / 2;
          const cvRight = cvLeft;

          // Bubble width approximately 300px
          const bubbleWidth = 300;
          const padding = 20;

          // Random vertical position (10% to 70% of viewport)
          const topPercent = 10 + Math.random() * 55;

          if (position === 'pos-dynamic-left') {
            // Position in left dark space - from left edge, ensuring bubble stays in dark area
            const maxLeft = Math.max(padding, cvLeft - bubbleWidth - padding);
            const leftPos = padding + Math.random() * Math.max(0, maxLeft - padding);
            this.speechBubble.style.left = leftPos + 'px';
            this.speechBubble.style.right = 'auto';
          } else {
            // Position in right dark space - from right edge
            const maxRight = Math.max(padding, cvRight - bubbleWidth - padding);
            const rightPos = padding + Math.random() * Math.max(0, maxRight - padding);
            this.speechBubble.style.right = rightPos + 'px';
            this.speechBubble.style.left = 'auto';
          }

          this.speechBubble.style.top = topPercent + '%';
          this.speechBubble.style.bottom = 'auto';
        } else if (isMobile) {
          // Mobile: use simple class, CSS handles positioning at bottom
          this.speechBubble.className = 'speech-bubble pos-dynamic ' + randomAnim;
          // Clear any inline styles - CSS will position at bottom
          this.speechBubble.style.top = '';
          this.speechBubble.style.bottom = '';
          this.speechBubble.style.left = '';
          this.speechBubble.style.right = '';
        } else {
          // Use fixed position class with random animation
          this.speechBubble.className = 'speech-bubble ' + position + ' ' + randomAnim;
          this.speechBubble.style.top = '';
          this.speechBubble.style.bottom = '';
          this.speechBubble.style.left = '';
          this.speechBubble.style.right = '';
        }

        // Show the bubble
        this.speechBubble.classList.add('visible');
      }

      hideSpeechBubble() {
        this.speechBubble.classList.remove('visible');
      }

      updateNavigation() {
        document.querySelectorAll('.nav-btn').forEach((btn, i) => btn.classList.toggle('active', i === this.currentSection));
      }

      goToSection(index) {
        this.isPlaying = false;
        this.hideSpeechBubble();
        this.playSection(index);
      }

      skipToNext() {
        // Stop any ongoing speech/presentation
        this.hideSpeechBubble();
        this.hideInfoPanel();
        // Move to next section if not at the end
        if (this.currentSection < 5) {
          this.isPlaying = true; // Ensure we're in playing mode
          this.playSection(this.currentSection + 1);
        }
      }

      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      animate() {
        requestAnimationFrame(() => this.animate());
        const time = performance.now() * 0.001;

        if (!this.boxUnpacked && this.boxGroup.visible) {
          this.boxGroup.position.y = Math.sin(time * 0.8) * 0.08;
          this.boxGroup.rotation.y = 0.3 + Math.sin(time * 0.5) * 0.05;
        }

        this.renderer.render(this.scene, this.camera);
      }
    }

    window.app = new App();
  </script>
</body>
</html>
